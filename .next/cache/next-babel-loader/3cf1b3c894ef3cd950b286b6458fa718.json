{"ast":null,"code":"import inherits from 'inherits';\nimport CommandInterceptor from 'diagram-js/lib/command/CommandInterceptor';\nimport { pointsAligned } from 'diagram-js/lib/util/Geometry';\nimport { assign } from 'min-dash';\nvar HIGH_PRIORITY = 3000;\n/**\n * Snaps connections with Manhattan layout.\n */\n\nexport default function LayoutConnectionBehavior(eventBus, gridSnapping, modeling) {\n  CommandInterceptor.call(this, eventBus);\n  this._gridSnapping = gridSnapping;\n  var self = this;\n  this.postExecuted(['connection.create', 'connection.layout'], HIGH_PRIORITY, function (event) {\n    var context = event.context,\n        connection = context.connection,\n        hints = context.hints || {},\n        waypoints = connection.waypoints;\n\n    if (hints.connectionStart || hints.connectionEnd || hints.createElementsBehavior === false) {\n      return;\n    }\n\n    if (!hasMiddleSegments(waypoints)) {\n      return;\n    }\n\n    modeling.updateWaypoints(connection, self.snapMiddleSegments(waypoints));\n  });\n}\nLayoutConnectionBehavior.$inject = ['eventBus', 'gridSnapping', 'modeling'];\ninherits(LayoutConnectionBehavior, CommandInterceptor);\n/**\n * Snap middle segments of a given connection.\n *\n * @param {Array<Point>} waypoints\n *\n * @returns {Array<Point>}\n */\n\nLayoutConnectionBehavior.prototype.snapMiddleSegments = function (waypoints) {\n  var gridSnapping = this._gridSnapping,\n      snapped;\n  waypoints = waypoints.slice();\n\n  for (var i = 1; i < waypoints.length - 2; i++) {\n    snapped = snapSegment(gridSnapping, waypoints[i], waypoints[i + 1]);\n    waypoints[i] = snapped[0];\n    waypoints[i + 1] = snapped[1];\n  }\n\n  return waypoints;\n}; // helpers //////////\n\n/**\n * Check whether a connection has a middle segments.\n *\n * @param {Array} waypoints\n *\n * @returns {boolean}\n */\n\n\nfunction hasMiddleSegments(waypoints) {\n  return waypoints.length > 3;\n}\n/**\n * Check whether an alignment is horizontal.\n *\n * @param {string} aligned\n *\n * @returns {boolean}\n */\n\n\nfunction horizontallyAligned(aligned) {\n  return aligned === 'h';\n}\n/**\n * Check whether an alignment is vertical.\n *\n * @param {string} aligned\n *\n * @returns {boolean}\n */\n\n\nfunction verticallyAligned(aligned) {\n  return aligned === 'v';\n}\n/**\n * Get middle segments from a given connection.\n *\n * @param {Array} waypoints\n *\n * @returns {Array}\n */\n\n\nfunction snapSegment(gridSnapping, segmentStart, segmentEnd) {\n  var aligned = pointsAligned(segmentStart, segmentEnd);\n  var snapped = {};\n\n  if (horizontallyAligned(aligned)) {\n    // snap horizontally\n    snapped.y = gridSnapping.snapValue(segmentStart.y);\n  }\n\n  if (verticallyAligned(aligned)) {\n    // snap vertically\n    snapped.x = gridSnapping.snapValue(segmentStart.x);\n  }\n\n  if ('x' in snapped || 'y' in snapped) {\n    segmentStart = assign({}, segmentStart, snapped);\n    segmentEnd = assign({}, segmentEnd, snapped);\n  }\n\n  return [segmentStart, segmentEnd];\n}","map":{"version":3,"sources":["/Users/believecreative/Kumar/bpmn/node_modules/bpmn-js/lib/features/grid-snapping/behavior/LayoutConnectionBehavior.js"],"names":["inherits","CommandInterceptor","pointsAligned","assign","HIGH_PRIORITY","LayoutConnectionBehavior","eventBus","gridSnapping","modeling","call","_gridSnapping","self","postExecuted","event","context","connection","hints","waypoints","connectionStart","connectionEnd","createElementsBehavior","hasMiddleSegments","updateWaypoints","snapMiddleSegments","$inject","prototype","snapped","slice","i","length","snapSegment","horizontallyAligned","aligned","verticallyAligned","segmentStart","segmentEnd","y","snapValue","x"],"mappings":"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","sourcesContent":["import inherits from 'inherits';\n\nimport CommandInterceptor from 'diagram-js/lib/command/CommandInterceptor';\n\nimport { pointsAligned } from 'diagram-js/lib/util/Geometry';\n\nimport {\n  assign\n} from 'min-dash';\n\nvar HIGH_PRIORITY = 3000;\n\n\n/**\n * Snaps connections with Manhattan layout.\n */\nexport default function LayoutConnectionBehavior(eventBus, gridSnapping, modeling) {\n  CommandInterceptor.call(this, eventBus);\n\n  this._gridSnapping = gridSnapping;\n\n  var self = this;\n\n  this.postExecuted([\n    'connection.create',\n    'connection.layout'\n  ], HIGH_PRIORITY, function(event) {\n    var context = event.context,\n        connection = context.connection,\n        hints = context.hints || {},\n        waypoints = connection.waypoints;\n\n    if (hints.connectionStart || hints.connectionEnd || hints.createElementsBehavior === false) {\n      return;\n    }\n\n    if (!hasMiddleSegments(waypoints)) {\n      return;\n    }\n\n    modeling.updateWaypoints(connection, self.snapMiddleSegments(waypoints));\n  });\n}\n\nLayoutConnectionBehavior.$inject = [\n  'eventBus',\n  'gridSnapping',\n  'modeling'\n];\n\ninherits(LayoutConnectionBehavior, CommandInterceptor);\n\n/**\n * Snap middle segments of a given connection.\n *\n * @param {Array<Point>} waypoints\n *\n * @returns {Array<Point>}\n */\nLayoutConnectionBehavior.prototype.snapMiddleSegments = function(waypoints) {\n  var gridSnapping = this._gridSnapping,\n      snapped;\n\n  waypoints = waypoints.slice();\n\n  for (var i = 1; i < waypoints.length - 2; i++) {\n\n    snapped = snapSegment(gridSnapping, waypoints[i], waypoints[i + 1]);\n\n    waypoints[i] = snapped[0];\n    waypoints[i + 1] = snapped[1];\n  }\n\n  return waypoints;\n};\n\n\n// helpers //////////\n\n/**\n * Check whether a connection has a middle segments.\n *\n * @param {Array} waypoints\n *\n * @returns {boolean}\n */\nfunction hasMiddleSegments(waypoints) {\n  return waypoints.length > 3;\n}\n\n/**\n * Check whether an alignment is horizontal.\n *\n * @param {string} aligned\n *\n * @returns {boolean}\n */\nfunction horizontallyAligned(aligned) {\n  return aligned === 'h';\n}\n\n/**\n * Check whether an alignment is vertical.\n *\n * @param {string} aligned\n *\n * @returns {boolean}\n */\nfunction verticallyAligned(aligned) {\n  return aligned === 'v';\n}\n\n/**\n * Get middle segments from a given connection.\n *\n * @param {Array} waypoints\n *\n * @returns {Array}\n */\nfunction snapSegment(gridSnapping, segmentStart, segmentEnd) {\n\n  var aligned = pointsAligned(segmentStart, segmentEnd);\n\n  var snapped = {};\n\n  if (horizontallyAligned(aligned)) {\n\n    // snap horizontally\n    snapped.y = gridSnapping.snapValue(segmentStart.y);\n  }\n\n  if (verticallyAligned(aligned)) {\n\n    // snap vertically\n    snapped.x = gridSnapping.snapValue(segmentStart.x);\n  }\n\n  if ('x' in snapped || 'y' in snapped) {\n    segmentStart = assign({}, segmentStart, snapped);\n    segmentEnd = assign({}, segmentEnd, snapped);\n  }\n\n  return [ segmentStart, segmentEnd ];\n}"]},"metadata":{},"sourceType":"module"}