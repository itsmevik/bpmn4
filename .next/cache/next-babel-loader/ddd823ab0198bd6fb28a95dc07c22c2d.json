{"ast":null,"code":"import { assign, forEach } from 'min-dash';\nimport inherits from 'inherits';\nimport { remove as collectionRemove, add as collectionAdd } from 'diagram-js/lib/util/Collections';\nimport { Label } from 'diagram-js/lib/model';\nimport { getBusinessObject, is } from '../../util/ModelUtil';\nimport { isAny } from './util/ModelingUtil';\nimport CommandInterceptor from 'diagram-js/lib/command/CommandInterceptor';\n/**\n * A handler responsible for updating the underlying BPMN 2.0 XML + DI\n * once changes on the diagram happen\n */\n\nexport default function BpmnUpdater(eventBus, bpmnFactory, connectionDocking, translate) {\n  CommandInterceptor.call(this, eventBus);\n  this._bpmnFactory = bpmnFactory;\n  this._translate = translate;\n  var self = this; // connection cropping //////////////////////\n  // crop connection ends during create/update\n\n  function cropConnection(e) {\n    var context = e.context,\n        hints = context.hints || {},\n        connection;\n\n    if (!context.cropped && hints.createElementsBehavior !== false) {\n      connection = context.connection;\n      connection.waypoints = connectionDocking.getCroppedWaypoints(connection);\n      context.cropped = true;\n    }\n  }\n\n  this.executed(['connection.layout', 'connection.create'], cropConnection);\n  this.reverted(['connection.layout'], function (e) {\n    delete e.context.cropped;\n  }); // BPMN + DI update //////////////////////\n  // update parent\n\n  function updateParent(e) {\n    var context = e.context;\n    self.updateParent(context.shape || context.connection, context.oldParent);\n  }\n\n  function reverseUpdateParent(e) {\n    var context = e.context;\n    var element = context.shape || context.connection,\n        // oldParent is the (old) new parent, because we are undoing\n    oldParent = context.parent || context.newParent;\n    self.updateParent(element, oldParent);\n  }\n\n  this.executed(['shape.move', 'shape.create', 'shape.delete', 'connection.create', 'connection.move', 'connection.delete'], ifBpmn(updateParent));\n  this.reverted(['shape.move', 'shape.create', 'shape.delete', 'connection.create', 'connection.move', 'connection.delete'], ifBpmn(reverseUpdateParent));\n  /*\n   * ## Updating Parent\n   *\n   * When morphing a Process into a Collaboration or vice-versa,\n   * make sure that both the *semantic* and *di* parent of each element\n   * is updated.\n   *\n   */\n\n  function updateRoot(event) {\n    var context = event.context,\n        oldRoot = context.oldRoot,\n        children = oldRoot.children;\n    forEach(children, function (child) {\n      if (is(child, 'bpmn:BaseElement')) {\n        self.updateParent(child);\n      }\n    });\n  }\n\n  this.executed(['canvas.updateRoot'], updateRoot);\n  this.reverted(['canvas.updateRoot'], updateRoot); // update bounds\n\n  function updateBounds(e) {\n    var shape = e.context.shape;\n\n    if (!is(shape, 'bpmn:BaseElement')) {\n      return;\n    }\n\n    self.updateBounds(shape);\n  }\n\n  this.executed(['shape.move', 'shape.create', 'shape.resize'], ifBpmn(function (event) {\n    // exclude labels because they're handled separately during shape.changed\n    if (event.context.shape.type === 'label') {\n      return;\n    }\n\n    updateBounds(event);\n  }));\n  this.reverted(['shape.move', 'shape.create', 'shape.resize'], ifBpmn(function (event) {\n    // exclude labels because they're handled separately during shape.changed\n    if (event.context.shape.type === 'label') {\n      return;\n    }\n\n    updateBounds(event);\n  })); // Handle labels separately. This is necessary, because the label bounds have to be updated\n  // every time its shape changes, not only on move, create and resize.\n\n  eventBus.on('shape.changed', function (event) {\n    if (event.element.type === 'label') {\n      updateBounds({\n        context: {\n          shape: event.element\n        }\n      });\n    }\n  }); // attach / detach connection\n\n  function updateConnection(e) {\n    self.updateConnection(e.context);\n  }\n\n  this.executed(['connection.create', 'connection.move', 'connection.delete', 'connection.reconnect'], ifBpmn(updateConnection));\n  this.reverted(['connection.create', 'connection.move', 'connection.delete', 'connection.reconnect'], ifBpmn(updateConnection)); // update waypoints\n\n  function updateConnectionWaypoints(e) {\n    self.updateConnectionWaypoints(e.context.connection);\n  }\n\n  this.executed(['connection.layout', 'connection.move', 'connection.updateWaypoints'], ifBpmn(updateConnectionWaypoints));\n  this.reverted(['connection.layout', 'connection.move', 'connection.updateWaypoints'], ifBpmn(updateConnectionWaypoints)); // update conditional/default flows\n\n  this.executed('connection.reconnect', ifBpmn(function (event) {\n    var context = event.context,\n        connection = context.connection,\n        oldSource = context.oldSource,\n        newSource = context.newSource,\n        connectionBo = getBusinessObject(connection),\n        oldSourceBo = getBusinessObject(oldSource),\n        newSourceBo = getBusinessObject(newSource); // remove condition from connection on reconnect to new source\n    // if new source can NOT have condional sequence flow\n\n    if (connectionBo.conditionExpression && !isAny(newSourceBo, ['bpmn:Activity', 'bpmn:ExclusiveGateway', 'bpmn:InclusiveGateway'])) {\n      context.oldConditionExpression = connectionBo.conditionExpression;\n      delete connectionBo.conditionExpression;\n    } // remove default from old source flow on reconnect to new source\n    // if source changed\n\n\n    if (oldSource !== newSource && oldSourceBo[\"default\"] === connectionBo) {\n      context.oldDefault = oldSourceBo[\"default\"];\n      delete oldSourceBo[\"default\"];\n    }\n  }));\n  this.reverted('connection.reconnect', ifBpmn(function (event) {\n    var context = event.context,\n        connection = context.connection,\n        oldSource = context.oldSource,\n        newSource = context.newSource,\n        connectionBo = getBusinessObject(connection),\n        oldSourceBo = getBusinessObject(oldSource),\n        newSourceBo = getBusinessObject(newSource); // add condition to connection on revert reconnect to new source\n\n    if (context.oldConditionExpression) {\n      connectionBo.conditionExpression = context.oldConditionExpression;\n    } // add default to old source on revert reconnect to new source\n\n\n    if (context.oldDefault) {\n      oldSourceBo[\"default\"] = context.oldDefault;\n      delete newSourceBo[\"default\"];\n    }\n  })); // update attachments\n\n  function updateAttachment(e) {\n    self.updateAttachment(e.context);\n  }\n\n  this.executed(['element.updateAttachment'], ifBpmn(updateAttachment));\n  this.reverted(['element.updateAttachment'], ifBpmn(updateAttachment));\n}\ninherits(BpmnUpdater, CommandInterceptor);\nBpmnUpdater.$inject = ['eventBus', 'bpmnFactory', 'connectionDocking', 'translate']; // implementation //////////////////////\n\nBpmnUpdater.prototype.updateAttachment = function (context) {\n  var shape = context.shape,\n      businessObject = shape.businessObject,\n      host = shape.host;\n  businessObject.attachedToRef = host && host.businessObject;\n};\n\nBpmnUpdater.prototype.updateParent = function (element, oldParent) {\n  // do not update BPMN 2.0 label parent\n  if (element instanceof Label) {\n    return;\n  } // data stores in collaborations are handled separately by DataStoreBehavior\n\n\n  if (is(element, 'bpmn:DataStoreReference') && element.parent && is(element.parent, 'bpmn:Collaboration')) {\n    return;\n  }\n\n  var parentShape = element.parent;\n  var businessObject = element.businessObject,\n      parentBusinessObject = parentShape && parentShape.businessObject,\n      parentDi = parentBusinessObject && parentBusinessObject.di;\n\n  if (is(element, 'bpmn:FlowNode')) {\n    this.updateFlowNodeRefs(businessObject, parentBusinessObject, oldParent && oldParent.businessObject);\n  }\n\n  if (is(element, 'bpmn:DataOutputAssociation')) {\n    if (element.source) {\n      parentBusinessObject = element.source.businessObject;\n    } else {\n      parentBusinessObject = null;\n    }\n  }\n\n  if (is(element, 'bpmn:DataInputAssociation')) {\n    if (element.target) {\n      parentBusinessObject = element.target.businessObject;\n    } else {\n      parentBusinessObject = null;\n    }\n  }\n\n  this.updateSemanticParent(businessObject, parentBusinessObject);\n\n  if (is(element, 'bpmn:DataObjectReference') && businessObject.dataObjectRef) {\n    this.updateSemanticParent(businessObject.dataObjectRef, parentBusinessObject);\n  }\n\n  this.updateDiParent(businessObject.di, parentDi);\n};\n\nBpmnUpdater.prototype.updateBounds = function (shape) {\n  var di = shape.businessObject.di;\n  var target = shape instanceof Label ? this._getLabel(di) : di;\n  var bounds = target.bounds;\n\n  if (!bounds) {\n    bounds = this._bpmnFactory.createDiBounds();\n    target.set('bounds', bounds);\n  }\n\n  assign(bounds, {\n    x: shape.x,\n    y: shape.y,\n    width: shape.width,\n    height: shape.height\n  });\n};\n\nBpmnUpdater.prototype.updateFlowNodeRefs = function (businessObject, newContainment, oldContainment) {\n  if (oldContainment === newContainment) {\n    return;\n  }\n\n  var oldRefs, newRefs;\n\n  if (is(oldContainment, 'bpmn:Lane')) {\n    oldRefs = oldContainment.get('flowNodeRef');\n    collectionRemove(oldRefs, businessObject);\n  }\n\n  if (is(newContainment, 'bpmn:Lane')) {\n    newRefs = newContainment.get('flowNodeRef');\n    collectionAdd(newRefs, businessObject);\n  }\n}; // update existing sourceElement and targetElement di information\n\n\nBpmnUpdater.prototype.updateDiConnection = function (di, newSource, newTarget) {\n  if (di.sourceElement && di.sourceElement.bpmnElement !== newSource) {\n    di.sourceElement = newSource && newSource.di;\n  }\n\n  if (di.targetElement && di.targetElement.bpmnElement !== newTarget) {\n    di.targetElement = newTarget && newTarget.di;\n  }\n};\n\nBpmnUpdater.prototype.updateDiParent = function (di, parentDi) {\n  if (parentDi && !is(parentDi, 'bpmndi:BPMNPlane')) {\n    parentDi = parentDi.$parent;\n  }\n\n  if (di.$parent === parentDi) {\n    return;\n  }\n\n  var planeElements = (parentDi || di.$parent).get('planeElement');\n\n  if (parentDi) {\n    planeElements.push(di);\n    di.$parent = parentDi;\n  } else {\n    collectionRemove(planeElements, di);\n    di.$parent = null;\n  }\n};\n\nfunction getDefinitions(element) {\n  while (element && !is(element, 'bpmn:Definitions')) {\n    element = element.$parent;\n  }\n\n  return element;\n}\n\nBpmnUpdater.prototype.getLaneSet = function (container) {\n  var laneSet, laneSets; // bpmn:Lane\n\n  if (is(container, 'bpmn:Lane')) {\n    laneSet = container.childLaneSet;\n\n    if (!laneSet) {\n      laneSet = this._bpmnFactory.create('bpmn:LaneSet');\n      container.childLaneSet = laneSet;\n      laneSet.$parent = container;\n    }\n\n    return laneSet;\n  } // bpmn:Participant\n\n\n  if (is(container, 'bpmn:Participant')) {\n    container = container.processRef;\n  } // bpmn:FlowElementsContainer\n\n\n  laneSets = container.get('laneSets');\n  laneSet = laneSets[0];\n\n  if (!laneSet) {\n    laneSet = this._bpmnFactory.create('bpmn:LaneSet');\n    laneSet.$parent = container;\n    laneSets.push(laneSet);\n  }\n\n  return laneSet;\n};\n\nBpmnUpdater.prototype.updateSemanticParent = function (businessObject, newParent, visualParent) {\n  var containment,\n      translate = this._translate;\n\n  if (businessObject.$parent === newParent) {\n    return;\n  }\n\n  if (is(businessObject, 'bpmn:DataInput') || is(businessObject, 'bpmn:DataOutput')) {\n    if (is(newParent, 'bpmn:Participant') && 'processRef' in newParent) {\n      newParent = newParent.processRef;\n    } // already in correct ioSpecification\n\n\n    if ('ioSpecification' in newParent && newParent.ioSpecification === businessObject.$parent) {\n      return;\n    }\n  }\n\n  if (is(businessObject, 'bpmn:Lane')) {\n    if (newParent) {\n      newParent = this.getLaneSet(newParent);\n    }\n\n    containment = 'lanes';\n  } else if (is(businessObject, 'bpmn:FlowElement')) {\n    if (newParent) {\n      if (is(newParent, 'bpmn:Participant')) {\n        newParent = newParent.processRef;\n      } else if (is(newParent, 'bpmn:Lane')) {\n        do {\n          // unwrap Lane -> LaneSet -> (Lane | FlowElementsContainer)\n          newParent = newParent.$parent.$parent;\n        } while (is(newParent, 'bpmn:Lane'));\n      }\n    }\n\n    containment = 'flowElements';\n  } else if (is(businessObject, 'bpmn:Artifact')) {\n    while (newParent && !is(newParent, 'bpmn:Process') && !is(newParent, 'bpmn:SubProcess') && !is(newParent, 'bpmn:Collaboration')) {\n      if (is(newParent, 'bpmn:Participant')) {\n        newParent = newParent.processRef;\n        break;\n      } else {\n        newParent = newParent.$parent;\n      }\n    }\n\n    containment = 'artifacts';\n  } else if (is(businessObject, 'bpmn:MessageFlow')) {\n    containment = 'messageFlows';\n  } else if (is(businessObject, 'bpmn:Participant')) {\n    containment = 'participants'; // make sure the participants process is properly attached / detached\n    // from the XML document\n\n    var process = businessObject.processRef,\n        definitions;\n\n    if (process) {\n      definitions = getDefinitions(businessObject.$parent || newParent);\n\n      if (businessObject.$parent) {\n        collectionRemove(definitions.get('rootElements'), process);\n        process.$parent = null;\n      }\n\n      if (newParent) {\n        collectionAdd(definitions.get('rootElements'), process);\n        process.$parent = definitions;\n      }\n    }\n  } else if (is(businessObject, 'bpmn:DataOutputAssociation')) {\n    containment = 'dataOutputAssociations';\n  } else if (is(businessObject, 'bpmn:DataInputAssociation')) {\n    containment = 'dataInputAssociations';\n  }\n\n  if (!containment) {\n    throw new Error(translate('no parent for {element} in {parent}', {\n      element: businessObject.id,\n      parent: newParent.id\n    }));\n  }\n\n  var children;\n\n  if (businessObject.$parent) {\n    // remove from old parent\n    children = businessObject.$parent.get(containment);\n    collectionRemove(children, businessObject);\n  }\n\n  if (!newParent) {\n    businessObject.$parent = null;\n  } else {\n    // add to new parent\n    children = newParent.get(containment);\n    children.push(businessObject);\n    businessObject.$parent = newParent;\n  }\n\n  if (visualParent) {\n    var diChildren = visualParent.get(containment);\n    collectionRemove(children, businessObject);\n\n    if (newParent) {\n      if (!diChildren) {\n        diChildren = [];\n        newParent.set(containment, diChildren);\n      }\n\n      diChildren.push(businessObject);\n    }\n  }\n};\n\nBpmnUpdater.prototype.updateConnectionWaypoints = function (connection) {\n  connection.businessObject.di.set('waypoint', this._bpmnFactory.createDiWaypoints(connection.waypoints));\n};\n\nBpmnUpdater.prototype.updateConnection = function (context) {\n  var connection = context.connection,\n      businessObject = getBusinessObject(connection),\n      newSource = getBusinessObject(connection.source),\n      newTarget = getBusinessObject(connection.target),\n      visualParent;\n\n  if (!is(businessObject, 'bpmn:DataAssociation')) {\n    var inverseSet = is(businessObject, 'bpmn:SequenceFlow');\n\n    if (businessObject.sourceRef !== newSource) {\n      if (inverseSet) {\n        collectionRemove(businessObject.sourceRef && businessObject.sourceRef.get('outgoing'), businessObject);\n\n        if (newSource && newSource.get('outgoing')) {\n          newSource.get('outgoing').push(businessObject);\n        }\n      }\n\n      businessObject.sourceRef = newSource;\n    }\n\n    if (businessObject.targetRef !== newTarget) {\n      if (inverseSet) {\n        collectionRemove(businessObject.targetRef && businessObject.targetRef.get('incoming'), businessObject);\n\n        if (newTarget && newTarget.get('incoming')) {\n          newTarget.get('incoming').push(businessObject);\n        }\n      }\n\n      businessObject.targetRef = newTarget;\n    }\n  } else if (is(businessObject, 'bpmn:DataInputAssociation')) {\n    // handle obnoxious isMsome sourceRef\n    businessObject.get('sourceRef')[0] = newSource;\n    visualParent = context.parent || context.newParent || newTarget;\n    this.updateSemanticParent(businessObject, newTarget, visualParent);\n  } else if (is(businessObject, 'bpmn:DataOutputAssociation')) {\n    visualParent = context.parent || context.newParent || newSource;\n    this.updateSemanticParent(businessObject, newSource, visualParent); // targetRef = new target\n\n    businessObject.targetRef = newTarget;\n  }\n\n  this.updateConnectionWaypoints(connection);\n  this.updateDiConnection(businessObject.di, newSource, newTarget);\n}; // helpers //////////////////////\n\n\nBpmnUpdater.prototype._getLabel = function (di) {\n  if (!di.label) {\n    di.label = this._bpmnFactory.createDiLabel();\n  }\n\n  return di.label;\n};\n/**\n * Make sure the event listener is only called\n * if the touched element is a BPMN element.\n *\n * @param  {Function} fn\n * @return {Function} guarded function\n */\n\n\nfunction ifBpmn(fn) {\n  return function (event) {\n    var context = event.context,\n        element = context.shape || context.connection;\n\n    if (is(element, 'bpmn:BaseElement')) {\n      fn(event);\n    }\n  };\n}","map":{"version":3,"sources":["/Users/believecreative/Kumar/bpmn/node_modules/bpmn-js/lib/features/modeling/BpmnUpdater.js"],"names":["assign","forEach","inherits","remove","collectionRemove","add","collectionAdd","Label","getBusinessObject","is","isAny","CommandInterceptor","BpmnUpdater","eventBus","bpmnFactory","connectionDocking","translate","call","_bpmnFactory","_translate","self","cropConnection","e","context","hints","connection","cropped","createElementsBehavior","waypoints","getCroppedWaypoints","executed","reverted","updateParent","shape","oldParent","reverseUpdateParent","element","parent","newParent","ifBpmn","updateRoot","event","oldRoot","children","child","updateBounds","type","on","updateConnection","updateConnectionWaypoints","oldSource","newSource","connectionBo","oldSourceBo","newSourceBo","conditionExpression","oldConditionExpression","oldDefault","updateAttachment","$inject","prototype","businessObject","host","attachedToRef","parentShape","parentBusinessObject","parentDi","di","updateFlowNodeRefs","source","target","updateSemanticParent","dataObjectRef","updateDiParent","_getLabel","bounds","createDiBounds","set","x","y","width","height","newContainment","oldContainment","oldRefs","newRefs","get","updateDiConnection","newTarget","sourceElement","bpmnElement","targetElement","$parent","planeElements","push","getDefinitions","getLaneSet","container","laneSet","laneSets","childLaneSet","create","processRef","visualParent","containment","ioSpecification","process","definitions","Error","id","diChildren","createDiWaypoints","inverseSet","sourceRef","targetRef","label","createDiLabel","fn"],"mappings":"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","sourcesContent":["import {\n  assign,\n  forEach\n} from 'min-dash';\n\nimport inherits from 'inherits';\n\nimport {\n  remove as collectionRemove,\n  add as collectionAdd\n} from 'diagram-js/lib/util/Collections';\n\nimport {\n  Label\n} from 'diagram-js/lib/model';\n\nimport {\n  getBusinessObject,\n  is\n} from '../../util/ModelUtil';\n\nimport {\n  isAny\n} from './util/ModelingUtil';\n\nimport CommandInterceptor from 'diagram-js/lib/command/CommandInterceptor';\n\n/**\n * A handler responsible for updating the underlying BPMN 2.0 XML + DI\n * once changes on the diagram happen\n */\nexport default function BpmnUpdater(\n    eventBus, bpmnFactory, connectionDocking,\n    translate) {\n\n  CommandInterceptor.call(this, eventBus);\n\n  this._bpmnFactory = bpmnFactory;\n  this._translate = translate;\n\n  var self = this;\n\n\n\n  // connection cropping //////////////////////\n\n  // crop connection ends during create/update\n  function cropConnection(e) {\n    var context = e.context,\n        hints = context.hints || {},\n        connection;\n\n    if (!context.cropped && hints.createElementsBehavior !== false) {\n      connection = context.connection;\n      connection.waypoints = connectionDocking.getCroppedWaypoints(connection);\n      context.cropped = true;\n    }\n  }\n\n  this.executed([\n    'connection.layout',\n    'connection.create'\n  ], cropConnection);\n\n  this.reverted([ 'connection.layout' ], function(e) {\n    delete e.context.cropped;\n  });\n\n\n\n  // BPMN + DI update //////////////////////\n\n\n  // update parent\n  function updateParent(e) {\n    var context = e.context;\n\n    self.updateParent(context.shape || context.connection, context.oldParent);\n  }\n\n  function reverseUpdateParent(e) {\n    var context = e.context;\n\n    var element = context.shape || context.connection,\n\n        // oldParent is the (old) new parent, because we are undoing\n        oldParent = context.parent || context.newParent;\n\n    self.updateParent(element, oldParent);\n  }\n\n  this.executed([\n    'shape.move',\n    'shape.create',\n    'shape.delete',\n    'connection.create',\n    'connection.move',\n    'connection.delete'\n  ], ifBpmn(updateParent));\n\n  this.reverted([\n    'shape.move',\n    'shape.create',\n    'shape.delete',\n    'connection.create',\n    'connection.move',\n    'connection.delete'\n  ], ifBpmn(reverseUpdateParent));\n\n  /*\n   * ## Updating Parent\n   *\n   * When morphing a Process into a Collaboration or vice-versa,\n   * make sure that both the *semantic* and *di* parent of each element\n   * is updated.\n   *\n   */\n  function updateRoot(event) {\n    var context = event.context,\n        oldRoot = context.oldRoot,\n        children = oldRoot.children;\n\n    forEach(children, function(child) {\n      if (is(child, 'bpmn:BaseElement')) {\n        self.updateParent(child);\n      }\n    });\n  }\n\n  this.executed([ 'canvas.updateRoot' ], updateRoot);\n  this.reverted([ 'canvas.updateRoot' ], updateRoot);\n\n\n  // update bounds\n  function updateBounds(e) {\n    var shape = e.context.shape;\n\n    if (!is(shape, 'bpmn:BaseElement')) {\n      return;\n    }\n\n    self.updateBounds(shape);\n  }\n\n  this.executed([ 'shape.move', 'shape.create', 'shape.resize' ], ifBpmn(function(event) {\n\n    // exclude labels because they're handled separately during shape.changed\n    if (event.context.shape.type === 'label') {\n      return;\n    }\n\n    updateBounds(event);\n  }));\n\n  this.reverted([ 'shape.move', 'shape.create', 'shape.resize' ], ifBpmn(function(event) {\n\n    // exclude labels because they're handled separately during shape.changed\n    if (event.context.shape.type === 'label') {\n      return;\n    }\n\n    updateBounds(event);\n  }));\n\n  // Handle labels separately. This is necessary, because the label bounds have to be updated\n  // every time its shape changes, not only on move, create and resize.\n  eventBus.on('shape.changed', function(event) {\n    if (event.element.type === 'label') {\n      updateBounds({ context: { shape: event.element } });\n    }\n  });\n\n  // attach / detach connection\n  function updateConnection(e) {\n    self.updateConnection(e.context);\n  }\n\n  this.executed([\n    'connection.create',\n    'connection.move',\n    'connection.delete',\n    'connection.reconnect'\n  ], ifBpmn(updateConnection));\n\n  this.reverted([\n    'connection.create',\n    'connection.move',\n    'connection.delete',\n    'connection.reconnect'\n  ], ifBpmn(updateConnection));\n\n\n  // update waypoints\n  function updateConnectionWaypoints(e) {\n    self.updateConnectionWaypoints(e.context.connection);\n  }\n\n  this.executed([\n    'connection.layout',\n    'connection.move',\n    'connection.updateWaypoints',\n  ], ifBpmn(updateConnectionWaypoints));\n\n  this.reverted([\n    'connection.layout',\n    'connection.move',\n    'connection.updateWaypoints',\n  ], ifBpmn(updateConnectionWaypoints));\n\n  // update conditional/default flows\n  this.executed('connection.reconnect', ifBpmn(function(event) {\n    var context = event.context,\n        connection = context.connection,\n        oldSource = context.oldSource,\n        newSource = context.newSource,\n        connectionBo = getBusinessObject(connection),\n        oldSourceBo = getBusinessObject(oldSource),\n        newSourceBo = getBusinessObject(newSource);\n\n    // remove condition from connection on reconnect to new source\n    // if new source can NOT have condional sequence flow\n    if (connectionBo.conditionExpression && !isAny(newSourceBo, [\n      'bpmn:Activity',\n      'bpmn:ExclusiveGateway',\n      'bpmn:InclusiveGateway'\n    ])) {\n      context.oldConditionExpression = connectionBo.conditionExpression;\n\n      delete connectionBo.conditionExpression;\n    }\n\n    // remove default from old source flow on reconnect to new source\n    // if source changed\n    if (oldSource !== newSource && oldSourceBo.default === connectionBo) {\n      context.oldDefault = oldSourceBo.default;\n\n      delete oldSourceBo.default;\n    }\n  }));\n\n  this.reverted('connection.reconnect', ifBpmn(function(event) {\n    var context = event.context,\n        connection = context.connection,\n        oldSource = context.oldSource,\n        newSource = context.newSource,\n        connectionBo = getBusinessObject(connection),\n        oldSourceBo = getBusinessObject(oldSource),\n        newSourceBo = getBusinessObject(newSource);\n\n    // add condition to connection on revert reconnect to new source\n    if (context.oldConditionExpression) {\n      connectionBo.conditionExpression = context.oldConditionExpression;\n    }\n\n    // add default to old source on revert reconnect to new source\n    if (context.oldDefault) {\n      oldSourceBo.default = context.oldDefault;\n\n      delete newSourceBo.default;\n    }\n  }));\n\n  // update attachments\n  function updateAttachment(e) {\n    self.updateAttachment(e.context);\n  }\n\n  this.executed([ 'element.updateAttachment' ], ifBpmn(updateAttachment));\n  this.reverted([ 'element.updateAttachment' ], ifBpmn(updateAttachment));\n}\n\ninherits(BpmnUpdater, CommandInterceptor);\n\nBpmnUpdater.$inject = [\n  'eventBus',\n  'bpmnFactory',\n  'connectionDocking',\n  'translate'\n];\n\n\n// implementation //////////////////////\n\nBpmnUpdater.prototype.updateAttachment = function(context) {\n\n  var shape = context.shape,\n      businessObject = shape.businessObject,\n      host = shape.host;\n\n  businessObject.attachedToRef = host && host.businessObject;\n};\n\nBpmnUpdater.prototype.updateParent = function(element, oldParent) {\n\n  // do not update BPMN 2.0 label parent\n  if (element instanceof Label) {\n    return;\n  }\n\n  // data stores in collaborations are handled separately by DataStoreBehavior\n  if (is(element, 'bpmn:DataStoreReference') &&\n      element.parent &&\n      is(element.parent, 'bpmn:Collaboration')) {\n    return;\n  }\n\n  var parentShape = element.parent;\n\n  var businessObject = element.businessObject,\n      parentBusinessObject = parentShape && parentShape.businessObject,\n      parentDi = parentBusinessObject && parentBusinessObject.di;\n\n  if (is(element, 'bpmn:FlowNode')) {\n    this.updateFlowNodeRefs(businessObject, parentBusinessObject, oldParent && oldParent.businessObject);\n  }\n\n  if (is(element, 'bpmn:DataOutputAssociation')) {\n    if (element.source) {\n      parentBusinessObject = element.source.businessObject;\n    } else {\n      parentBusinessObject = null;\n    }\n  }\n\n  if (is(element, 'bpmn:DataInputAssociation')) {\n    if (element.target) {\n      parentBusinessObject = element.target.businessObject;\n    } else {\n      parentBusinessObject = null;\n    }\n  }\n\n  this.updateSemanticParent(businessObject, parentBusinessObject);\n\n  if (is(element, 'bpmn:DataObjectReference') && businessObject.dataObjectRef) {\n    this.updateSemanticParent(businessObject.dataObjectRef, parentBusinessObject);\n  }\n\n  this.updateDiParent(businessObject.di, parentDi);\n};\n\n\nBpmnUpdater.prototype.updateBounds = function(shape) {\n\n  var di = shape.businessObject.di;\n\n  var target = (shape instanceof Label) ? this._getLabel(di) : di;\n\n  var bounds = target.bounds;\n\n  if (!bounds) {\n    bounds = this._bpmnFactory.createDiBounds();\n    target.set('bounds', bounds);\n  }\n\n  assign(bounds, {\n    x: shape.x,\n    y: shape.y,\n    width: shape.width,\n    height: shape.height\n  });\n};\n\nBpmnUpdater.prototype.updateFlowNodeRefs = function(businessObject, newContainment, oldContainment) {\n\n  if (oldContainment === newContainment) {\n    return;\n  }\n\n  var oldRefs, newRefs;\n\n  if (is (oldContainment, 'bpmn:Lane')) {\n    oldRefs = oldContainment.get('flowNodeRef');\n    collectionRemove(oldRefs, businessObject);\n  }\n\n  if (is(newContainment, 'bpmn:Lane')) {\n    newRefs = newContainment.get('flowNodeRef');\n    collectionAdd(newRefs, businessObject);\n  }\n};\n\n\n// update existing sourceElement and targetElement di information\nBpmnUpdater.prototype.updateDiConnection = function(di, newSource, newTarget) {\n\n  if (di.sourceElement && di.sourceElement.bpmnElement !== newSource) {\n    di.sourceElement = newSource && newSource.di;\n  }\n\n  if (di.targetElement && di.targetElement.bpmnElement !== newTarget) {\n    di.targetElement = newTarget && newTarget.di;\n  }\n\n};\n\n\nBpmnUpdater.prototype.updateDiParent = function(di, parentDi) {\n\n  if (parentDi && !is(parentDi, 'bpmndi:BPMNPlane')) {\n    parentDi = parentDi.$parent;\n  }\n\n  if (di.$parent === parentDi) {\n    return;\n  }\n\n  var planeElements = (parentDi || di.$parent).get('planeElement');\n\n  if (parentDi) {\n    planeElements.push(di);\n    di.$parent = parentDi;\n  } else {\n    collectionRemove(planeElements, di);\n    di.$parent = null;\n  }\n};\n\nfunction getDefinitions(element) {\n  while (element && !is(element, 'bpmn:Definitions')) {\n    element = element.$parent;\n  }\n\n  return element;\n}\n\nBpmnUpdater.prototype.getLaneSet = function(container) {\n\n  var laneSet, laneSets;\n\n  // bpmn:Lane\n  if (is(container, 'bpmn:Lane')) {\n    laneSet = container.childLaneSet;\n\n    if (!laneSet) {\n      laneSet = this._bpmnFactory.create('bpmn:LaneSet');\n      container.childLaneSet = laneSet;\n      laneSet.$parent = container;\n    }\n\n    return laneSet;\n  }\n\n  // bpmn:Participant\n  if (is(container, 'bpmn:Participant')) {\n    container = container.processRef;\n  }\n\n  // bpmn:FlowElementsContainer\n  laneSets = container.get('laneSets');\n  laneSet = laneSets[0];\n\n  if (!laneSet) {\n    laneSet = this._bpmnFactory.create('bpmn:LaneSet');\n    laneSet.$parent = container;\n    laneSets.push(laneSet);\n  }\n\n  return laneSet;\n};\n\nBpmnUpdater.prototype.updateSemanticParent = function(businessObject, newParent, visualParent) {\n\n  var containment,\n      translate = this._translate;\n\n  if (businessObject.$parent === newParent) {\n    return;\n  }\n\n  if (is(businessObject, 'bpmn:DataInput') || is(businessObject, 'bpmn:DataOutput')) {\n\n    if (is(newParent, 'bpmn:Participant') && 'processRef' in newParent) {\n      newParent = newParent.processRef;\n    }\n\n    // already in correct ioSpecification\n    if ('ioSpecification' in newParent && newParent.ioSpecification === businessObject.$parent) {\n      return;\n    }\n  }\n\n  if (is(businessObject, 'bpmn:Lane')) {\n\n    if (newParent) {\n      newParent = this.getLaneSet(newParent);\n    }\n\n    containment = 'lanes';\n  } else\n\n  if (is(businessObject, 'bpmn:FlowElement')) {\n\n    if (newParent) {\n\n      if (is(newParent, 'bpmn:Participant')) {\n        newParent = newParent.processRef;\n      } else\n\n      if (is(newParent, 'bpmn:Lane')) {\n        do {\n\n          // unwrap Lane -> LaneSet -> (Lane | FlowElementsContainer)\n          newParent = newParent.$parent.$parent;\n        } while (is(newParent, 'bpmn:Lane'));\n\n      }\n    }\n\n    containment = 'flowElements';\n\n  } else\n\n  if (is(businessObject, 'bpmn:Artifact')) {\n\n    while (newParent &&\n           !is(newParent, 'bpmn:Process') &&\n           !is(newParent, 'bpmn:SubProcess') &&\n           !is(newParent, 'bpmn:Collaboration')) {\n\n      if (is(newParent, 'bpmn:Participant')) {\n        newParent = newParent.processRef;\n        break;\n      } else {\n        newParent = newParent.$parent;\n      }\n    }\n\n    containment = 'artifacts';\n  } else\n\n  if (is(businessObject, 'bpmn:MessageFlow')) {\n    containment = 'messageFlows';\n\n  } else\n\n  if (is(businessObject, 'bpmn:Participant')) {\n    containment = 'participants';\n\n    // make sure the participants process is properly attached / detached\n    // from the XML document\n\n    var process = businessObject.processRef,\n        definitions;\n\n    if (process) {\n      definitions = getDefinitions(businessObject.$parent || newParent);\n\n      if (businessObject.$parent) {\n        collectionRemove(definitions.get('rootElements'), process);\n        process.$parent = null;\n      }\n\n      if (newParent) {\n        collectionAdd(definitions.get('rootElements'), process);\n        process.$parent = definitions;\n      }\n    }\n  } else\n\n  if (is(businessObject, 'bpmn:DataOutputAssociation')) {\n    containment = 'dataOutputAssociations';\n  } else\n\n  if (is(businessObject, 'bpmn:DataInputAssociation')) {\n    containment = 'dataInputAssociations';\n  }\n\n  if (!containment) {\n    throw new Error(translate(\n      'no parent for {element} in {parent}',\n      {\n        element: businessObject.id,\n        parent: newParent.id\n      }\n    ));\n  }\n\n  var children;\n\n  if (businessObject.$parent) {\n\n    // remove from old parent\n    children = businessObject.$parent.get(containment);\n    collectionRemove(children, businessObject);\n  }\n\n  if (!newParent) {\n    businessObject.$parent = null;\n  } else {\n\n    // add to new parent\n    children = newParent.get(containment);\n    children.push(businessObject);\n    businessObject.$parent = newParent;\n  }\n\n  if (visualParent) {\n    var diChildren = visualParent.get(containment);\n\n    collectionRemove(children, businessObject);\n\n    if (newParent) {\n\n      if (!diChildren) {\n        diChildren = [];\n        newParent.set(containment, diChildren);\n      }\n\n      diChildren.push(businessObject);\n    }\n  }\n};\n\n\nBpmnUpdater.prototype.updateConnectionWaypoints = function(connection) {\n  connection.businessObject.di.set('waypoint', this._bpmnFactory.createDiWaypoints(connection.waypoints));\n};\n\n\nBpmnUpdater.prototype.updateConnection = function(context) {\n\n  var connection = context.connection,\n      businessObject = getBusinessObject(connection),\n      newSource = getBusinessObject(connection.source),\n      newTarget = getBusinessObject(connection.target),\n      visualParent;\n\n  if (!is(businessObject, 'bpmn:DataAssociation')) {\n\n    var inverseSet = is(businessObject, 'bpmn:SequenceFlow');\n\n    if (businessObject.sourceRef !== newSource) {\n      if (inverseSet) {\n        collectionRemove(businessObject.sourceRef && businessObject.sourceRef.get('outgoing'), businessObject);\n\n        if (newSource && newSource.get('outgoing')) {\n          newSource.get('outgoing').push(businessObject);\n        }\n      }\n\n      businessObject.sourceRef = newSource;\n    }\n\n    if (businessObject.targetRef !== newTarget) {\n      if (inverseSet) {\n        collectionRemove(businessObject.targetRef && businessObject.targetRef.get('incoming'), businessObject);\n\n        if (newTarget && newTarget.get('incoming')) {\n          newTarget.get('incoming').push(businessObject);\n        }\n      }\n\n      businessObject.targetRef = newTarget;\n    }\n  } else\n\n  if (is(businessObject, 'bpmn:DataInputAssociation')) {\n\n    // handle obnoxious isMsome sourceRef\n    businessObject.get('sourceRef')[0] = newSource;\n\n    visualParent = context.parent || context.newParent || newTarget;\n\n    this.updateSemanticParent(businessObject, newTarget, visualParent);\n  } else\n\n  if (is(businessObject, 'bpmn:DataOutputAssociation')) {\n    visualParent = context.parent || context.newParent || newSource;\n\n    this.updateSemanticParent(businessObject, newSource, visualParent);\n\n    // targetRef = new target\n    businessObject.targetRef = newTarget;\n  }\n\n  this.updateConnectionWaypoints(connection);\n\n  this.updateDiConnection(businessObject.di, newSource, newTarget);\n};\n\n\n// helpers //////////////////////\n\nBpmnUpdater.prototype._getLabel = function(di) {\n  if (!di.label) {\n    di.label = this._bpmnFactory.createDiLabel();\n  }\n\n  return di.label;\n};\n\n\n/**\n * Make sure the event listener is only called\n * if the touched element is a BPMN element.\n *\n * @param  {Function} fn\n * @return {Function} guarded function\n */\nfunction ifBpmn(fn) {\n\n  return function(event) {\n\n    var context = event.context,\n        element = context.shape || context.connection;\n\n    if (is(element, 'bpmn:BaseElement')) {\n      fn(event);\n    }\n  };\n}\n"]},"metadata":{},"sourceType":"module"}