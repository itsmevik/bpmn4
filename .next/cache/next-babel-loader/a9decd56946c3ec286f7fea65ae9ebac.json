{"ast":null,"code":"import inherits from 'inherits';\nimport { assign } from 'min-dash';\nimport BaseLayouter from 'diagram-js/lib/layout/BaseLayouter';\nimport { repairConnection, withoutRedundantPoints } from 'diagram-js/lib/layout/ManhattanLayout';\nimport { getMid, getOrientation } from 'diagram-js/lib/layout/LayoutUtil';\nimport { isExpanded } from '../../util/DiUtil';\nimport { is } from '../../util/ModelUtil';\nvar ATTACH_ORIENTATION_PADDING = -10,\n    BOUNDARY_TO_HOST_THRESHOLD = 40;\nvar oppositeOrientationMapping = {\n  'top': 'bottom',\n  'top-right': 'bottom-left',\n  'top-left': 'bottom-right',\n  'right': 'left',\n  'bottom': 'top',\n  'bottom-right': 'top-left',\n  'bottom-left': 'top-right',\n  'left': 'right'\n};\nvar orientationDirectionMapping = {\n  top: 't',\n  right: 'r',\n  bottom: 'b',\n  left: 'l'\n};\nexport default function BpmnLayouter() {}\ninherits(BpmnLayouter, BaseLayouter);\n\nBpmnLayouter.prototype.layoutConnection = function (connection, hints) {\n  if (!hints) {\n    hints = {};\n  }\n\n  var source = hints.source || connection.source,\n      target = hints.target || connection.target,\n      waypoints = hints.waypoints || connection.waypoints,\n      connectionStart = hints.connectionStart,\n      connectionEnd = hints.connectionEnd;\n  var manhattanOptions, updatedWaypoints;\n\n  if (!connectionStart) {\n    connectionStart = getConnectionDocking(waypoints && waypoints[0], source);\n  }\n\n  if (!connectionEnd) {\n    connectionEnd = getConnectionDocking(waypoints && waypoints[waypoints.length - 1], target);\n  } // TODO(nikku): support vertical modeling\n  // and invert preferredLayouts accordingly\n\n\n  if (is(connection, 'bpmn:Association') || is(connection, 'bpmn:DataAssociation')) {\n    if (waypoints && !isCompensationAssociation(source, target)) {\n      return [].concat([connectionStart], waypoints.slice(1, -1), [connectionEnd]);\n    }\n  }\n\n  if (is(connection, 'bpmn:MessageFlow')) {\n    manhattanOptions = getMessageFlowManhattanOptions(source, target);\n  } else if (is(connection, 'bpmn:SequenceFlow') || isCompensationAssociation(source, target)) {\n    // layout all connection between flow elements h:h, except for\n    // (1) outgoing of boundary events -> layout based on attach orientation and target orientation\n    // (2) incoming/outgoing of gateways -> v:h for outgoing, h:v for incoming\n    // (3) loops\n    if (source === target) {\n      manhattanOptions = {\n        preferredLayouts: getLoopPreferredLayout(source, connection)\n      };\n    } else if (is(source, 'bpmn:BoundaryEvent')) {\n      manhattanOptions = {\n        preferredLayouts: getBoundaryEventPreferredLayouts(source, target, connectionEnd)\n      };\n    } else if (is(source, 'bpmn:Gateway')) {\n      manhattanOptions = {\n        preferredLayouts: ['v:h']\n      };\n    } else if (is(target, 'bpmn:Gateway')) {\n      manhattanOptions = {\n        preferredLayouts: ['h:v']\n      };\n    } else {\n      manhattanOptions = {\n        preferredLayouts: ['h:h']\n      };\n    }\n  }\n\n  if (manhattanOptions) {\n    manhattanOptions = assign(manhattanOptions, hints);\n    updatedWaypoints = withoutRedundantPoints(repairConnection(source, target, connectionStart, connectionEnd, waypoints, manhattanOptions));\n  }\n\n  return updatedWaypoints || [connectionStart, connectionEnd];\n}; // helpers //////////\n\n\nfunction getAttachOrientation(attachedElement) {\n  var hostElement = attachedElement.host;\n  return getOrientation(getMid(attachedElement), hostElement, ATTACH_ORIENTATION_PADDING);\n}\n\nfunction getMessageFlowManhattanOptions(source, target) {\n  return {\n    preferredLayouts: ['straight', 'v:v'],\n    preserveDocking: getMessageFlowPreserveDocking(source, target)\n  };\n}\n\nfunction getMessageFlowPreserveDocking(source, target) {\n  // (1) docking element connected to participant has precedence\n  if (is(target, 'bpmn:Participant')) {\n    return 'source';\n  }\n\n  if (is(source, 'bpmn:Participant')) {\n    return 'target';\n  } // (2) docking element connected to expanded sub-process has precedence\n\n\n  if (isExpandedSubProcess(target)) {\n    return 'source';\n  }\n\n  if (isExpandedSubProcess(source)) {\n    return 'target';\n  } // (3) docking event has precedence\n\n\n  if (is(target, 'bpmn:Event')) {\n    return 'target';\n  }\n\n  if (is(source, 'bpmn:Event')) {\n    return 'source';\n  }\n\n  return null;\n}\n\nfunction getConnectionDocking(point, shape) {\n  return point ? point.original || point : getMid(shape);\n}\n\nfunction isCompensationAssociation(source, target) {\n  return is(target, 'bpmn:Activity') && is(source, 'bpmn:BoundaryEvent') && target.businessObject.isForCompensation;\n}\n\nfunction isExpandedSubProcess(element) {\n  return is(element, 'bpmn:SubProcess') && isExpanded(element);\n}\n\nfunction isSame(a, b) {\n  return a === b;\n}\n\nfunction isAnyOrientation(orientation, orientations) {\n  return orientations.indexOf(orientation) !== -1;\n}\n\nfunction getHorizontalOrientation(orientation) {\n  var matches = /right|left/.exec(orientation);\n  return matches && matches[0];\n}\n\nfunction getVerticalOrientation(orientation) {\n  var matches = /top|bottom/.exec(orientation);\n  return matches && matches[0];\n}\n\nfunction isOppositeOrientation(a, b) {\n  return oppositeOrientationMapping[a] === b;\n}\n\nfunction isOppositeHorizontalOrientation(a, b) {\n  var horizontalOrientation = getHorizontalOrientation(a);\n  var oppositeHorizontalOrientation = oppositeOrientationMapping[horizontalOrientation];\n  return b.indexOf(oppositeHorizontalOrientation) !== -1;\n}\n\nfunction isOppositeVerticalOrientation(a, b) {\n  var verticalOrientation = getVerticalOrientation(a);\n  var oppositeVerticalOrientation = oppositeOrientationMapping[verticalOrientation];\n  return b.indexOf(oppositeVerticalOrientation) !== -1;\n}\n\nfunction isHorizontalOrientation(orientation) {\n  return orientation === 'right' || orientation === 'left';\n}\n\nfunction getLoopPreferredLayout(source, connection) {\n  var waypoints = connection.waypoints;\n  var orientation = waypoints && waypoints.length && getOrientation(waypoints[0], source);\n\n  if (orientation === 'top') {\n    return ['t:r'];\n  } else if (orientation === 'right') {\n    return ['r:b'];\n  } else if (orientation === 'left') {\n    return ['l:t'];\n  }\n\n  return ['b:l'];\n}\n\nfunction getBoundaryEventPreferredLayouts(source, target, end) {\n  var sourceMid = getMid(source),\n      targetMid = getMid(target),\n      attachOrientation = getAttachOrientation(source),\n      sourceLayout,\n      targetLayout;\n  var isLoop = isSame(source.host, target);\n  var attachedToSide = isAnyOrientation(attachOrientation, ['top', 'right', 'bottom', 'left']);\n  var targetOrientation = getOrientation(targetMid, sourceMid, {\n    x: source.width / 2 + target.width / 2,\n    y: source.height / 2 + target.height / 2\n  });\n\n  if (isLoop) {\n    return getBoundaryEventLoopLayout(attachOrientation, attachedToSide, source, target, end);\n  } // source layout\n\n\n  sourceLayout = getBoundaryEventSourceLayout(attachOrientation, targetOrientation, attachedToSide); // target layout\n\n  targetLayout = getBoundaryEventTargetLayout(attachOrientation, targetOrientation, attachedToSide);\n  return [sourceLayout + ':' + targetLayout];\n}\n\nfunction getBoundaryEventLoopLayout(attachOrientation, attachedToSide, source, target, end) {\n  var orientation = attachedToSide ? attachOrientation : getVerticalOrientation(attachOrientation),\n      sourceLayout = orientationDirectionMapping[orientation],\n      targetLayout;\n\n  if (attachedToSide) {\n    if (isHorizontalOrientation(attachOrientation)) {\n      targetLayout = shouldConnectToSameSide('y', source, target, end) ? 'h' : 'b';\n    } else {\n      targetLayout = shouldConnectToSameSide('x', source, target, end) ? 'v' : 'l';\n    }\n  } else {\n    targetLayout = 'v';\n  }\n\n  return [sourceLayout + ':' + targetLayout];\n}\n\nfunction shouldConnectToSameSide(axis, source, target, end) {\n  var threshold = BOUNDARY_TO_HOST_THRESHOLD;\n  return !(areCloseOnAxis(axis, end, target, threshold) || areCloseOnAxis(axis, end, {\n    x: target.x + target.width,\n    y: target.y + target.height\n  }, threshold) || areCloseOnAxis(axis, end, getMid(source), threshold));\n}\n\nfunction areCloseOnAxis(axis, a, b, threshold) {\n  return Math.abs(a[axis] - b[axis]) < threshold;\n}\n\nfunction getBoundaryEventSourceLayout(attachOrientation, targetOrientation, attachedToSide) {\n  // attached to either top, right, bottom or left side\n  if (attachedToSide) {\n    return orientationDirectionMapping[attachOrientation];\n  } // attached to either top-right, top-left, bottom-right or bottom-left corner\n  // same vertical or opposite horizontal orientation\n\n\n  if (isSame(getVerticalOrientation(attachOrientation), getVerticalOrientation(targetOrientation)) || isOppositeOrientation(getHorizontalOrientation(attachOrientation), getHorizontalOrientation(targetOrientation))) {\n    return orientationDirectionMapping[getVerticalOrientation(attachOrientation)];\n  } // fallback\n\n\n  return orientationDirectionMapping[getHorizontalOrientation(attachOrientation)];\n}\n\nfunction getBoundaryEventTargetLayout(attachOrientation, targetOrientation, attachedToSide) {\n  // attached to either top, right, bottom or left side\n  if (attachedToSide) {\n    if (isHorizontalOrientation(attachOrientation)) {\n      // orientation is right or left\n      // opposite horizontal orientation or same orientation\n      if (isOppositeHorizontalOrientation(attachOrientation, targetOrientation) || isSame(attachOrientation, targetOrientation)) {\n        return 'h';\n      } // fallback\n\n\n      return 'v';\n    } else {\n      // orientation is top or bottom\n      // opposite vertical orientation or same orientation\n      if (isOppositeVerticalOrientation(attachOrientation, targetOrientation) || isSame(attachOrientation, targetOrientation)) {\n        return 'v';\n      } // fallback\n\n\n      return 'h';\n    }\n  } // attached to either top-right, top-left, bottom-right or bottom-left corner\n  // orientation is right, left\n  // or same vertical orientation but also right or left\n\n\n  if (isHorizontalOrientation(targetOrientation) || isSame(getVerticalOrientation(attachOrientation), getVerticalOrientation(targetOrientation)) && getHorizontalOrientation(targetOrientation)) {\n    return 'h';\n  } else {\n    return 'v';\n  }\n}","map":{"version":3,"sources":["/Users/believecreative/Kumar/bpmn/node_modules/bpmn-js/lib/features/modeling/BpmnLayouter.js"],"names":["inherits","assign","BaseLayouter","repairConnection","withoutRedundantPoints","getMid","getOrientation","isExpanded","is","ATTACH_ORIENTATION_PADDING","BOUNDARY_TO_HOST_THRESHOLD","oppositeOrientationMapping","orientationDirectionMapping","top","right","bottom","left","BpmnLayouter","prototype","layoutConnection","connection","hints","source","target","waypoints","connectionStart","connectionEnd","manhattanOptions","updatedWaypoints","getConnectionDocking","length","isCompensationAssociation","concat","slice","getMessageFlowManhattanOptions","preferredLayouts","getLoopPreferredLayout","getBoundaryEventPreferredLayouts","getAttachOrientation","attachedElement","hostElement","host","preserveDocking","getMessageFlowPreserveDocking","isExpandedSubProcess","point","shape","original","businessObject","isForCompensation","element","isSame","a","b","isAnyOrientation","orientation","orientations","indexOf","getHorizontalOrientation","matches","exec","getVerticalOrientation","isOppositeOrientation","isOppositeHorizontalOrientation","horizontalOrientation","oppositeHorizontalOrientation","isOppositeVerticalOrientation","verticalOrientation","oppositeVerticalOrientation","isHorizontalOrientation","end","sourceMid","targetMid","attachOrientation","sourceLayout","targetLayout","isLoop","attachedToSide","targetOrientation","x","width","y","height","getBoundaryEventLoopLayout","getBoundaryEventSourceLayout","getBoundaryEventTargetLayout","shouldConnectToSameSide","axis","threshold","areCloseOnAxis","Math","abs"],"mappings":"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","sourcesContent":["import inherits from 'inherits';\n\nimport {\n  assign\n} from 'min-dash';\n\nimport BaseLayouter from 'diagram-js/lib/layout/BaseLayouter';\n\nimport {\n  repairConnection,\n  withoutRedundantPoints\n} from 'diagram-js/lib/layout/ManhattanLayout';\n\nimport {\n  getMid,\n  getOrientation\n} from 'diagram-js/lib/layout/LayoutUtil';\n\nimport {\n  isExpanded\n} from '../../util/DiUtil';\n\nimport { is } from '../../util/ModelUtil';\n\nvar ATTACH_ORIENTATION_PADDING = -10,\n    BOUNDARY_TO_HOST_THRESHOLD = 40;\n\nvar oppositeOrientationMapping = {\n  'top': 'bottom',\n  'top-right': 'bottom-left',\n  'top-left': 'bottom-right',\n  'right': 'left',\n  'bottom': 'top',\n  'bottom-right': 'top-left',\n  'bottom-left': 'top-right',\n  'left': 'right'\n};\n\nvar orientationDirectionMapping = {\n  top: 't',\n  right: 'r',\n  bottom: 'b',\n  left: 'l'\n};\n\n\nexport default function BpmnLayouter() {}\n\ninherits(BpmnLayouter, BaseLayouter);\n\n\nBpmnLayouter.prototype.layoutConnection = function(connection, hints) {\n  if (!hints) {\n    hints = {};\n  }\n\n  var source = hints.source || connection.source,\n      target = hints.target || connection.target,\n      waypoints = hints.waypoints || connection.waypoints,\n      connectionStart = hints.connectionStart,\n      connectionEnd = hints.connectionEnd;\n\n  var manhattanOptions,\n      updatedWaypoints;\n\n  if (!connectionStart) {\n    connectionStart = getConnectionDocking(waypoints && waypoints[ 0 ], source);\n  }\n\n  if (!connectionEnd) {\n    connectionEnd = getConnectionDocking(waypoints && waypoints[ waypoints.length - 1 ], target);\n  }\n\n  // TODO(nikku): support vertical modeling\n  // and invert preferredLayouts accordingly\n\n  if (is(connection, 'bpmn:Association') ||\n      is(connection, 'bpmn:DataAssociation')) {\n\n    if (waypoints && !isCompensationAssociation(source, target)) {\n      return [].concat([ connectionStart ], waypoints.slice(1, -1), [ connectionEnd ]);\n    }\n  }\n\n  if (is(connection, 'bpmn:MessageFlow')) {\n    manhattanOptions = getMessageFlowManhattanOptions(source, target);\n  } else if (is(connection, 'bpmn:SequenceFlow') || isCompensationAssociation(source, target)) {\n\n    // layout all connection between flow elements h:h, except for\n    // (1) outgoing of boundary events -> layout based on attach orientation and target orientation\n    // (2) incoming/outgoing of gateways -> v:h for outgoing, h:v for incoming\n    // (3) loops\n    if (source === target) {\n      manhattanOptions = {\n        preferredLayouts: getLoopPreferredLayout(source, connection)\n      };\n    } else if (is(source, 'bpmn:BoundaryEvent')) {\n      manhattanOptions = {\n        preferredLayouts: getBoundaryEventPreferredLayouts(source, target, connectionEnd)\n      };\n    } else if (is(source, 'bpmn:Gateway')) {\n      manhattanOptions = {\n        preferredLayouts: [ 'v:h' ]\n      };\n    } else if (is(target, 'bpmn:Gateway')) {\n      manhattanOptions = {\n        preferredLayouts: [ 'h:v' ]\n      };\n    } else {\n      manhattanOptions = {\n        preferredLayouts: [ 'h:h' ]\n      };\n    }\n  }\n\n  if (manhattanOptions) {\n    manhattanOptions = assign(manhattanOptions, hints);\n\n    updatedWaypoints = withoutRedundantPoints(repairConnection(\n      source,\n      target,\n      connectionStart,\n      connectionEnd,\n      waypoints,\n      manhattanOptions\n    ));\n  }\n\n  return updatedWaypoints || [ connectionStart, connectionEnd ];\n};\n\n\n// helpers //////////\n\nfunction getAttachOrientation(attachedElement) {\n  var hostElement = attachedElement.host;\n\n  return getOrientation(getMid(attachedElement), hostElement, ATTACH_ORIENTATION_PADDING);\n}\n\nfunction getMessageFlowManhattanOptions(source, target) {\n  return {\n    preferredLayouts: [ 'straight', 'v:v' ],\n    preserveDocking: getMessageFlowPreserveDocking(source, target)\n  };\n}\n\nfunction getMessageFlowPreserveDocking(source, target) {\n\n  // (1) docking element connected to participant has precedence\n  if (is(target, 'bpmn:Participant')) {\n    return 'source';\n  }\n\n  if (is(source, 'bpmn:Participant')) {\n    return 'target';\n  }\n\n  // (2) docking element connected to expanded sub-process has precedence\n  if (isExpandedSubProcess(target)) {\n    return 'source';\n  }\n\n  if (isExpandedSubProcess(source)) {\n    return 'target';\n  }\n\n  // (3) docking event has precedence\n  if (is(target, 'bpmn:Event')) {\n    return 'target';\n  }\n\n  if (is(source, 'bpmn:Event')) {\n    return 'source';\n  }\n\n  return null;\n}\n\nfunction getConnectionDocking(point, shape) {\n  return point ? (point.original || point) : getMid(shape);\n}\n\nfunction isCompensationAssociation(source, target) {\n  return is(target, 'bpmn:Activity') &&\n    is(source, 'bpmn:BoundaryEvent') &&\n    target.businessObject.isForCompensation;\n}\n\nfunction isExpandedSubProcess(element) {\n  return is(element, 'bpmn:SubProcess') && isExpanded(element);\n}\n\nfunction isSame(a, b) {\n  return a === b;\n}\n\nfunction isAnyOrientation(orientation, orientations) {\n  return orientations.indexOf(orientation) !== -1;\n}\n\nfunction getHorizontalOrientation(orientation) {\n  var matches = /right|left/.exec(orientation);\n\n  return matches && matches[0];\n}\n\nfunction getVerticalOrientation(orientation) {\n  var matches = /top|bottom/.exec(orientation);\n\n  return matches && matches[0];\n}\n\nfunction isOppositeOrientation(a, b) {\n  return oppositeOrientationMapping[a] === b;\n}\n\nfunction isOppositeHorizontalOrientation(a, b) {\n  var horizontalOrientation = getHorizontalOrientation(a);\n\n  var oppositeHorizontalOrientation = oppositeOrientationMapping[horizontalOrientation];\n\n  return b.indexOf(oppositeHorizontalOrientation) !== -1;\n}\n\nfunction isOppositeVerticalOrientation(a, b) {\n  var verticalOrientation = getVerticalOrientation(a);\n\n  var oppositeVerticalOrientation = oppositeOrientationMapping[verticalOrientation];\n\n  return b.indexOf(oppositeVerticalOrientation) !== -1;\n}\n\nfunction isHorizontalOrientation(orientation) {\n  return orientation === 'right' || orientation === 'left';\n}\n\nfunction getLoopPreferredLayout(source, connection) {\n  var waypoints = connection.waypoints;\n\n  var orientation = waypoints && waypoints.length && getOrientation(waypoints[0], source);\n\n  if (orientation === 'top') {\n    return [ 't:r' ];\n  } else if (orientation === 'right') {\n    return [ 'r:b' ];\n  } else if (orientation === 'left') {\n    return [ 'l:t' ];\n  }\n\n  return [ 'b:l' ];\n}\n\nfunction getBoundaryEventPreferredLayouts(source, target, end) {\n  var sourceMid = getMid(source),\n      targetMid = getMid(target),\n      attachOrientation = getAttachOrientation(source),\n      sourceLayout,\n      targetLayout;\n\n  var isLoop = isSame(source.host, target);\n\n  var attachedToSide = isAnyOrientation(attachOrientation, [ 'top', 'right', 'bottom', 'left' ]);\n\n  var targetOrientation = getOrientation(targetMid, sourceMid, {\n    x: source.width / 2 + target.width / 2,\n    y: source.height / 2 + target.height / 2\n  });\n\n  if (isLoop) {\n    return getBoundaryEventLoopLayout(attachOrientation, attachedToSide, source, target, end);\n  }\n\n  // source layout\n  sourceLayout = getBoundaryEventSourceLayout(attachOrientation, targetOrientation, attachedToSide);\n\n  // target layout\n  targetLayout = getBoundaryEventTargetLayout(attachOrientation, targetOrientation, attachedToSide);\n\n  return [ sourceLayout + ':' + targetLayout ];\n}\n\nfunction getBoundaryEventLoopLayout(attachOrientation, attachedToSide, source, target, end) {\n  var orientation = attachedToSide ? attachOrientation : getVerticalOrientation(attachOrientation),\n      sourceLayout = orientationDirectionMapping[ orientation ],\n      targetLayout;\n\n  if (attachedToSide) {\n    if (isHorizontalOrientation(attachOrientation)) {\n      targetLayout = shouldConnectToSameSide('y', source, target, end) ? 'h' : 'b';\n    } else {\n      targetLayout = shouldConnectToSameSide('x', source, target, end) ? 'v' : 'l';\n    }\n  } else {\n    targetLayout = 'v';\n  }\n\n  return [ sourceLayout + ':' + targetLayout ];\n}\n\nfunction shouldConnectToSameSide(axis, source, target, end) {\n  var threshold = BOUNDARY_TO_HOST_THRESHOLD;\n\n  return !(\n    areCloseOnAxis(axis, end, target, threshold) ||\n    areCloseOnAxis(axis, end, {\n      x: target.x + target.width,\n      y: target.y + target.height\n    }, threshold) ||\n    areCloseOnAxis(axis, end, getMid(source), threshold)\n  );\n}\n\nfunction areCloseOnAxis(axis, a, b, threshold) {\n  return Math.abs(a[ axis ] - b[ axis ]) < threshold;\n}\n\nfunction getBoundaryEventSourceLayout(attachOrientation, targetOrientation, attachedToSide) {\n\n  // attached to either top, right, bottom or left side\n  if (attachedToSide) {\n    return orientationDirectionMapping[ attachOrientation ];\n  }\n\n  // attached to either top-right, top-left, bottom-right or bottom-left corner\n\n  // same vertical or opposite horizontal orientation\n  if (isSame(\n    getVerticalOrientation(attachOrientation), getVerticalOrientation(targetOrientation)\n  ) || isOppositeOrientation(\n    getHorizontalOrientation(attachOrientation), getHorizontalOrientation(targetOrientation)\n  )) {\n    return orientationDirectionMapping[ getVerticalOrientation(attachOrientation) ];\n  }\n\n  // fallback\n  return orientationDirectionMapping[ getHorizontalOrientation(attachOrientation) ];\n}\n\nfunction getBoundaryEventTargetLayout(attachOrientation, targetOrientation, attachedToSide) {\n\n  // attached to either top, right, bottom or left side\n  if (attachedToSide) {\n    if (isHorizontalOrientation(attachOrientation)) {\n\n      // orientation is right or left\n\n      // opposite horizontal orientation or same orientation\n      if (\n        isOppositeHorizontalOrientation(attachOrientation, targetOrientation) ||\n        isSame(attachOrientation, targetOrientation)\n      ) {\n        return 'h';\n      }\n\n      // fallback\n      return 'v';\n    } else {\n\n      // orientation is top or bottom\n\n      // opposite vertical orientation or same orientation\n      if (\n        isOppositeVerticalOrientation(attachOrientation, targetOrientation) ||\n        isSame(attachOrientation, targetOrientation)\n      ) {\n        return 'v';\n      }\n\n      // fallback\n      return 'h';\n    }\n  }\n\n  // attached to either top-right, top-left, bottom-right or bottom-left corner\n\n  // orientation is right, left\n  // or same vertical orientation but also right or left\n  if (isHorizontalOrientation(targetOrientation) ||\n    (isSame(getVerticalOrientation(attachOrientation), getVerticalOrientation(targetOrientation)) &&\n      getHorizontalOrientation(targetOrientation))) {\n    return 'h';\n  } else {\n    return 'v';\n  }\n}\n"]},"metadata":{},"sourceType":"module"}