{"ast":null,"code":"import { is } from '../../../../util/ModelUtil';\nimport { asTRBL } from 'diagram-js/lib/layout/LayoutUtil';\nimport { collectLanes, getLanesRoot } from '../../../modeling/util/LaneUtil';\nvar abs = Math.abs,\n    min = Math.min,\n    max = Math.max;\n\nfunction addToTrbl(trbl, attr, value, choice) {\n  var current = trbl[attr]; // make sure to set the value if it does not exist\n  // or apply the correct value by comparing against\n  // choice(value, currentValue)\n\n  trbl[attr] = current === undefined ? value : choice(value, current);\n}\n\nfunction addMin(trbl, attr, value) {\n  return addToTrbl(trbl, attr, value, min);\n}\n\nfunction addMax(trbl, attr, value) {\n  return addToTrbl(trbl, attr, value, max);\n}\n\nvar LANE_MIN_HEIGHT = 60,\n    LANE_MIN_WIDTH = 300,\n    LANE_RIGHT_PADDING = 20,\n    LANE_LEFT_PADDING = 50,\n    LANE_TOP_PADDING = 20,\n    LANE_BOTTOM_PADDING = 20;\nexport function getParticipantResizeConstraints(laneShape, resizeDirection, balanced) {\n  var lanesRoot = getLanesRoot(laneShape);\n  var isFirst = true,\n      isLast = true; // max top/bottom size for lanes\n\n  var allLanes = collectLanes(lanesRoot, [lanesRoot]);\n  var laneTrbl = asTRBL(laneShape);\n  var maxTrbl = {},\n      minTrbl = {};\n\n  if (/e/.test(resizeDirection)) {\n    minTrbl.right = laneTrbl.left + LANE_MIN_WIDTH;\n  } else if (/w/.test(resizeDirection)) {\n    minTrbl.left = laneTrbl.right - LANE_MIN_WIDTH;\n  }\n\n  allLanes.forEach(function (other) {\n    var otherTrbl = asTRBL(other);\n\n    if (/n/.test(resizeDirection)) {\n      if (otherTrbl.top < laneTrbl.top - 10) {\n        isFirst = false;\n      } // max top size (based on next element)\n\n\n      if (balanced && abs(laneTrbl.top - otherTrbl.bottom) < 10) {\n        addMax(maxTrbl, 'top', otherTrbl.top + LANE_MIN_HEIGHT);\n      } // min top size (based on self or nested element)\n\n\n      if (abs(laneTrbl.top - otherTrbl.top) < 5) {\n        addMin(minTrbl, 'top', otherTrbl.bottom - LANE_MIN_HEIGHT);\n      }\n    }\n\n    if (/s/.test(resizeDirection)) {\n      if (otherTrbl.bottom > laneTrbl.bottom + 10) {\n        isLast = false;\n      } // max bottom size (based on previous element)\n\n\n      if (balanced && abs(laneTrbl.bottom - otherTrbl.top) < 10) {\n        addMin(maxTrbl, 'bottom', otherTrbl.bottom - LANE_MIN_HEIGHT);\n      } // min bottom size (based on self or nested element)\n\n\n      if (abs(laneTrbl.bottom - otherTrbl.bottom) < 5) {\n        addMax(minTrbl, 'bottom', otherTrbl.top + LANE_MIN_HEIGHT);\n      }\n    }\n  }); // max top/bottom/left/right size based on flow nodes\n\n  var flowElements = lanesRoot.children.filter(function (s) {\n    return !s.hidden && !s.waypoints && (is(s, 'bpmn:FlowElement') || is(s, 'bpmn:Artifact'));\n  });\n  flowElements.forEach(function (flowElement) {\n    var flowElementTrbl = asTRBL(flowElement);\n\n    if (isFirst && /n/.test(resizeDirection)) {\n      addMin(minTrbl, 'top', flowElementTrbl.top - LANE_TOP_PADDING);\n    }\n\n    if (/e/.test(resizeDirection)) {\n      addMax(minTrbl, 'right', flowElementTrbl.right + LANE_RIGHT_PADDING);\n    }\n\n    if (isLast && /s/.test(resizeDirection)) {\n      addMax(minTrbl, 'bottom', flowElementTrbl.bottom + LANE_BOTTOM_PADDING);\n    }\n\n    if (/w/.test(resizeDirection)) {\n      addMin(minTrbl, 'left', flowElementTrbl.left - LANE_LEFT_PADDING);\n    }\n  });\n  return {\n    min: minTrbl,\n    max: maxTrbl\n  };\n}","map":{"version":3,"sources":["/Users/believecreative/Kumar/bpmn/node_modules/bpmn-js/lib/features/modeling/behavior/util/ResizeUtil.js"],"names":["is","asTRBL","collectLanes","getLanesRoot","abs","Math","min","max","addToTrbl","trbl","attr","value","choice","current","undefined","addMin","addMax","LANE_MIN_HEIGHT","LANE_MIN_WIDTH","LANE_RIGHT_PADDING","LANE_LEFT_PADDING","LANE_TOP_PADDING","LANE_BOTTOM_PADDING","getParticipantResizeConstraints","laneShape","resizeDirection","balanced","lanesRoot","isFirst","isLast","allLanes","laneTrbl","maxTrbl","minTrbl","test","right","left","forEach","other","otherTrbl","top","bottom","flowElements","children","filter","s","hidden","waypoints","flowElement","flowElementTrbl"],"mappings":"AAAA,SAASA,EAAT,QAAmB,4BAAnB;AAEA,SACEC,MADF,QAEO,kCAFP;AAIA,SACEC,YADF,EAEEC,YAFF,QAGO,iCAHP;AAKA,IAAIC,GAAG,GAAGC,IAAI,CAACD,GAAf;AAAA,IACIE,GAAG,GAAGD,IAAI,CAACC,GADf;AAAA,IAEIC,GAAG,GAAGF,IAAI,CAACE,GAFf;;AAKA,SAASC,SAAT,CAAmBC,IAAnB,EAAyBC,IAAzB,EAA+BC,KAA/B,EAAsCC,MAAtC,EAA8C;AAC5C,MAAIC,OAAO,GAAGJ,IAAI,CAACC,IAAD,CAAlB,CAD4C,CAG5C;AACA;AACA;;AACAD,EAAAA,IAAI,CAACC,IAAD,CAAJ,GAAaG,OAAO,KAAKC,SAAZ,GAAwBH,KAAxB,GAAgCC,MAAM,CAACD,KAAD,EAAQE,OAAR,CAAnD;AACD;;AAED,SAASE,MAAT,CAAgBN,IAAhB,EAAsBC,IAAtB,EAA4BC,KAA5B,EAAmC;AACjC,SAAOH,SAAS,CAACC,IAAD,EAAOC,IAAP,EAAaC,KAAb,EAAoBL,GAApB,CAAhB;AACD;;AAED,SAASU,MAAT,CAAgBP,IAAhB,EAAsBC,IAAtB,EAA4BC,KAA5B,EAAmC;AACjC,SAAOH,SAAS,CAACC,IAAD,EAAOC,IAAP,EAAaC,KAAb,EAAoBJ,GAApB,CAAhB;AACD;;AAED,IAAIU,eAAe,GAAG,EAAtB;AAAA,IACIC,cAAc,GAAG,GADrB;AAAA,IAEIC,kBAAkB,GAAG,EAFzB;AAAA,IAGIC,iBAAiB,GAAG,EAHxB;AAAA,IAIIC,gBAAgB,GAAG,EAJvB;AAAA,IAKIC,mBAAmB,GAAG,EAL1B;AAQA,OAAO,SAASC,+BAAT,CAAyCC,SAAzC,EAAoDC,eAApD,EAAqEC,QAArE,EAA+E;AACpF,MAAIC,SAAS,GAAGxB,YAAY,CAACqB,SAAD,CAA5B;AAEA,MAAII,OAAO,GAAG,IAAd;AAAA,MACIC,MAAM,GAAG,IADb,CAHoF,CAMpF;;AACA,MAAIC,QAAQ,GAAG5B,YAAY,CAACyB,SAAD,EAAY,CAAEA,SAAF,CAAZ,CAA3B;AAEA,MAAII,QAAQ,GAAG9B,MAAM,CAACuB,SAAD,CAArB;AAEA,MAAIQ,OAAO,GAAG,EAAd;AAAA,MACIC,OAAO,GAAG,EADd;;AAGA,MAAI,IAAIC,IAAJ,CAAST,eAAT,CAAJ,EAA+B;AAC7BQ,IAAAA,OAAO,CAACE,KAAR,GAAgBJ,QAAQ,CAACK,IAAT,GAAgBlB,cAAhC;AACD,GAFD,MAGA,IAAI,IAAIgB,IAAJ,CAAST,eAAT,CAAJ,EAA+B;AAC7BQ,IAAAA,OAAO,CAACG,IAAR,GAAeL,QAAQ,CAACI,KAAT,GAAiBjB,cAAhC;AACD;;AAEDY,EAAAA,QAAQ,CAACO,OAAT,CAAiB,UAASC,KAAT,EAAgB;AAE/B,QAAIC,SAAS,GAAGtC,MAAM,CAACqC,KAAD,CAAtB;;AAEA,QAAI,IAAIJ,IAAJ,CAAST,eAAT,CAAJ,EAA+B;AAE7B,UAAIc,SAAS,CAACC,GAAV,GAAiBT,QAAQ,CAACS,GAAT,GAAe,EAApC,EAAyC;AACvCZ,QAAAA,OAAO,GAAG,KAAV;AACD,OAJ4B,CAM7B;;;AACA,UAAIF,QAAQ,IAAItB,GAAG,CAAC2B,QAAQ,CAACS,GAAT,GAAeD,SAAS,CAACE,MAA1B,CAAH,GAAuC,EAAvD,EAA2D;AACzDzB,QAAAA,MAAM,CAACgB,OAAD,EAAU,KAAV,EAAiBO,SAAS,CAACC,GAAV,GAAgBvB,eAAjC,CAAN;AACD,OAT4B,CAW7B;;;AACA,UAAIb,GAAG,CAAC2B,QAAQ,CAACS,GAAT,GAAeD,SAAS,CAACC,GAA1B,CAAH,GAAoC,CAAxC,EAA2C;AACzCzB,QAAAA,MAAM,CAACkB,OAAD,EAAU,KAAV,EAAiBM,SAAS,CAACE,MAAV,GAAmBxB,eAApC,CAAN;AACD;AACF;;AAED,QAAI,IAAIiB,IAAJ,CAAST,eAAT,CAAJ,EAA+B;AAE7B,UAAIc,SAAS,CAACE,MAAV,GAAoBV,QAAQ,CAACU,MAAT,GAAkB,EAA1C,EAA+C;AAC7CZ,QAAAA,MAAM,GAAG,KAAT;AACD,OAJ4B,CAM7B;;;AACA,UAAIH,QAAQ,IAAItB,GAAG,CAAC2B,QAAQ,CAACU,MAAT,GAAkBF,SAAS,CAACC,GAA7B,CAAH,GAAuC,EAAvD,EAA2D;AACzDzB,QAAAA,MAAM,CAACiB,OAAD,EAAU,QAAV,EAAoBO,SAAS,CAACE,MAAV,GAAmBxB,eAAvC,CAAN;AACD,OAT4B,CAW7B;;;AACA,UAAIb,GAAG,CAAC2B,QAAQ,CAACU,MAAT,GAAkBF,SAAS,CAACE,MAA7B,CAAH,GAA0C,CAA9C,EAAiD;AAC/CzB,QAAAA,MAAM,CAACiB,OAAD,EAAU,QAAV,EAAoBM,SAAS,CAACC,GAAV,GAAgBvB,eAApC,CAAN;AACD;AACF;AACF,GArCD,EArBoF,CA4DpF;;AACA,MAAIyB,YAAY,GAAGf,SAAS,CAACgB,QAAV,CAAmBC,MAAnB,CAA0B,UAASC,CAAT,EAAY;AACvD,WAAO,CAACA,CAAC,CAACC,MAAH,IAAa,CAACD,CAAC,CAACE,SAAhB,KAA8B/C,EAAE,CAAC6C,CAAD,EAAI,kBAAJ,CAAF,IAA6B7C,EAAE,CAAC6C,CAAD,EAAI,eAAJ,CAA7D,CAAP;AACD,GAFkB,CAAnB;AAIAH,EAAAA,YAAY,CAACL,OAAb,CAAqB,UAASW,WAAT,EAAsB;AAEzC,QAAIC,eAAe,GAAGhD,MAAM,CAAC+C,WAAD,CAA5B;;AAEA,QAAIpB,OAAO,IAAI,IAAIM,IAAJ,CAAST,eAAT,CAAf,EAA0C;AACxCV,MAAAA,MAAM,CAACkB,OAAD,EAAU,KAAV,EAAiBgB,eAAe,CAACT,GAAhB,GAAsBnB,gBAAvC,CAAN;AACD;;AAED,QAAI,IAAIa,IAAJ,CAAST,eAAT,CAAJ,EAA+B;AAC7BT,MAAAA,MAAM,CAACiB,OAAD,EAAU,OAAV,EAAmBgB,eAAe,CAACd,KAAhB,GAAwBhB,kBAA3C,CAAN;AACD;;AAED,QAAIU,MAAM,IAAI,IAAIK,IAAJ,CAAST,eAAT,CAAd,EAAyC;AACvCT,MAAAA,MAAM,CAACiB,OAAD,EAAU,QAAV,EAAoBgB,eAAe,CAACR,MAAhB,GAAyBnB,mBAA7C,CAAN;AACD;;AAED,QAAI,IAAIY,IAAJ,CAAST,eAAT,CAAJ,EAA+B;AAC7BV,MAAAA,MAAM,CAACkB,OAAD,EAAU,MAAV,EAAkBgB,eAAe,CAACb,IAAhB,GAAuBhB,iBAAzC,CAAN;AACD;AACF,GAnBD;AAqBA,SAAO;AACLd,IAAAA,GAAG,EAAE2B,OADA;AAEL1B,IAAAA,GAAG,EAAEyB;AAFA,GAAP;AAID","sourcesContent":["import { is } from '../../../../util/ModelUtil';\r\n\r\nimport {\r\n  asTRBL\r\n} from 'diagram-js/lib/layout/LayoutUtil';\r\n\r\nimport {\r\n  collectLanes,\r\n  getLanesRoot\r\n} from '../../../modeling/util/LaneUtil';\r\n\r\nvar abs = Math.abs,\r\n    min = Math.min,\r\n    max = Math.max;\r\n\r\n\r\nfunction addToTrbl(trbl, attr, value, choice) {\r\n  var current = trbl[attr];\r\n\r\n  // make sure to set the value if it does not exist\r\n  // or apply the correct value by comparing against\r\n  // choice(value, currentValue)\r\n  trbl[attr] = current === undefined ? value : choice(value, current);\r\n}\r\n\r\nfunction addMin(trbl, attr, value) {\r\n  return addToTrbl(trbl, attr, value, min);\r\n}\r\n\r\nfunction addMax(trbl, attr, value) {\r\n  return addToTrbl(trbl, attr, value, max);\r\n}\r\n\r\nvar LANE_MIN_HEIGHT = 60,\r\n    LANE_MIN_WIDTH = 300,\r\n    LANE_RIGHT_PADDING = 20,\r\n    LANE_LEFT_PADDING = 50,\r\n    LANE_TOP_PADDING = 20,\r\n    LANE_BOTTOM_PADDING = 20;\r\n\r\n\r\nexport function getParticipantResizeConstraints(laneShape, resizeDirection, balanced) {\r\n  var lanesRoot = getLanesRoot(laneShape);\r\n\r\n  var isFirst = true,\r\n      isLast = true;\r\n\r\n  // max top/bottom size for lanes\r\n  var allLanes = collectLanes(lanesRoot, [ lanesRoot ]);\r\n\r\n  var laneTrbl = asTRBL(laneShape);\r\n\r\n  var maxTrbl = {},\r\n      minTrbl = {};\r\n\r\n  if (/e/.test(resizeDirection)) {\r\n    minTrbl.right = laneTrbl.left + LANE_MIN_WIDTH;\r\n  } else\r\n  if (/w/.test(resizeDirection)) {\r\n    minTrbl.left = laneTrbl.right - LANE_MIN_WIDTH;\r\n  }\r\n\r\n  allLanes.forEach(function(other) {\r\n\r\n    var otherTrbl = asTRBL(other);\r\n\r\n    if (/n/.test(resizeDirection)) {\r\n\r\n      if (otherTrbl.top < (laneTrbl.top - 10)) {\r\n        isFirst = false;\r\n      }\r\n\r\n      // max top size (based on next element)\r\n      if (balanced && abs(laneTrbl.top - otherTrbl.bottom) < 10) {\r\n        addMax(maxTrbl, 'top', otherTrbl.top + LANE_MIN_HEIGHT);\r\n      }\r\n\r\n      // min top size (based on self or nested element)\r\n      if (abs(laneTrbl.top - otherTrbl.top) < 5) {\r\n        addMin(minTrbl, 'top', otherTrbl.bottom - LANE_MIN_HEIGHT);\r\n      }\r\n    }\r\n\r\n    if (/s/.test(resizeDirection)) {\r\n\r\n      if (otherTrbl.bottom > (laneTrbl.bottom + 10)) {\r\n        isLast = false;\r\n      }\r\n\r\n      // max bottom size (based on previous element)\r\n      if (balanced && abs(laneTrbl.bottom - otherTrbl.top) < 10) {\r\n        addMin(maxTrbl, 'bottom', otherTrbl.bottom - LANE_MIN_HEIGHT);\r\n      }\r\n\r\n      // min bottom size (based on self or nested element)\r\n      if (abs(laneTrbl.bottom - otherTrbl.bottom) < 5) {\r\n        addMax(minTrbl, 'bottom', otherTrbl.top + LANE_MIN_HEIGHT);\r\n      }\r\n    }\r\n  });\r\n\r\n  // max top/bottom/left/right size based on flow nodes\r\n  var flowElements = lanesRoot.children.filter(function(s) {\r\n    return !s.hidden && !s.waypoints && (is(s, 'bpmn:FlowElement') || is(s, 'bpmn:Artifact'));\r\n  });\r\n\r\n  flowElements.forEach(function(flowElement) {\r\n\r\n    var flowElementTrbl = asTRBL(flowElement);\r\n\r\n    if (isFirst && /n/.test(resizeDirection)) {\r\n      addMin(minTrbl, 'top', flowElementTrbl.top - LANE_TOP_PADDING);\r\n    }\r\n\r\n    if (/e/.test(resizeDirection)) {\r\n      addMax(minTrbl, 'right', flowElementTrbl.right + LANE_RIGHT_PADDING);\r\n    }\r\n\r\n    if (isLast && /s/.test(resizeDirection)) {\r\n      addMax(minTrbl, 'bottom', flowElementTrbl.bottom + LANE_BOTTOM_PADDING);\r\n    }\r\n\r\n    if (/w/.test(resizeDirection)) {\r\n      addMin(minTrbl, 'left', flowElementTrbl.left - LANE_LEFT_PADDING);\r\n    }\r\n  });\r\n\r\n  return {\r\n    min: minTrbl,\r\n    max: maxTrbl\r\n  };\r\n}"]},"metadata":{},"sourceType":"module"}