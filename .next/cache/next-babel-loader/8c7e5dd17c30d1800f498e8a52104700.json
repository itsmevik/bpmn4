{"ast":null,"code":"import inherits from 'inherits';\nimport { getOrientation, getMid, asTRBL } from 'diagram-js/lib/layout/LayoutUtil';\nimport { substract } from 'diagram-js/lib/util/Math';\nimport { hasExternalLabel } from '../../../util/LabelUtil';\nimport CommandInterceptor from 'diagram-js/lib/command/CommandInterceptor';\nvar ALIGNMENTS = ['top', 'bottom', 'left', 'right'];\nvar ELEMENT_LABEL_DISTANCE = 10;\n/**\n * A component that makes sure that external labels are added\n * together with respective elements and properly updated (DI wise)\n * during move.\n *\n * @param {EventBus} eventBus\n * @param {Modeling} modeling\n */\n\nexport default function AdaptiveLabelPositioningBehavior(eventBus, modeling) {\n  CommandInterceptor.call(this, eventBus);\n  this.postExecuted(['connection.create', 'connection.layout', 'connection.updateWaypoints'], function (event) {\n    var context = event.context,\n        connection = context.connection,\n        source = connection.source,\n        target = connection.target,\n        hints = context.hints || {};\n\n    if (hints.createElementsBehavior !== false) {\n      checkLabelAdjustment(source);\n      checkLabelAdjustment(target);\n    }\n  });\n  this.postExecuted(['label.create'], function (event) {\n    var context = event.context,\n        shape = context.shape,\n        hints = context.hints || {};\n\n    if (hints.createElementsBehavior !== false) {\n      checkLabelAdjustment(shape.labelTarget);\n    }\n  });\n  this.postExecuted(['elements.create'], function (event) {\n    var context = event.context,\n        elements = context.elements,\n        hints = context.hints || {};\n\n    if (hints.createElementsBehavior !== false) {\n      elements.forEach(function (element) {\n        checkLabelAdjustment(element);\n      });\n    }\n  });\n\n  function checkLabelAdjustment(element) {\n    // skip non-existing labels\n    if (!hasExternalLabel(element)) {\n      return;\n    }\n\n    var optimalPosition = getOptimalPosition(element); // no optimal position found\n\n    if (!optimalPosition) {\n      return;\n    }\n\n    adjustLabelPosition(element, optimalPosition);\n  }\n\n  function adjustLabelPosition(element, orientation) {\n    var elementMid = getMid(element),\n        label = element.label,\n        labelMid = getMid(label); // ignore labels that are being created\n\n    if (!label.parent) {\n      return;\n    }\n\n    var elementTrbl = asTRBL(element);\n    var newLabelMid;\n\n    switch (orientation) {\n      case 'top':\n        newLabelMid = {\n          x: elementMid.x,\n          y: elementTrbl.top - ELEMENT_LABEL_DISTANCE - label.height / 2\n        };\n        break;\n\n      case 'left':\n        newLabelMid = {\n          x: elementTrbl.left - ELEMENT_LABEL_DISTANCE - label.width / 2,\n          y: elementMid.y\n        };\n        break;\n\n      case 'bottom':\n        newLabelMid = {\n          x: elementMid.x,\n          y: elementTrbl.bottom + ELEMENT_LABEL_DISTANCE + label.height / 2\n        };\n        break;\n\n      case 'right':\n        newLabelMid = {\n          x: elementTrbl.right + ELEMENT_LABEL_DISTANCE + label.width / 2,\n          y: elementMid.y\n        };\n        break;\n    }\n\n    var delta = substract(newLabelMid, labelMid);\n    modeling.moveShape(label, delta);\n  }\n}\ninherits(AdaptiveLabelPositioningBehavior, CommandInterceptor);\nAdaptiveLabelPositioningBehavior.$inject = ['eventBus', 'modeling']; // helpers //////////////////////\n\n/**\n * Return alignments which are taken by a boundary's host element\n *\n * @param {Shape} element\n *\n * @return {Array<String>}\n */\n\nfunction getTakenHostAlignments(element) {\n  var hostElement = element.host,\n      elementMid = getMid(element),\n      hostOrientation = getOrientation(elementMid, hostElement);\n  var freeAlignments; // check whether there is a multi-orientation, e.g. 'top-left'\n\n  if (hostOrientation.indexOf('-') >= 0) {\n    freeAlignments = hostOrientation.split('-');\n  } else {\n    freeAlignments = [hostOrientation];\n  }\n\n  var takenAlignments = ALIGNMENTS.filter(function (alignment) {\n    return freeAlignments.indexOf(alignment) === -1;\n  });\n  return takenAlignments;\n}\n/**\n * Return alignments which are taken by related connections\n *\n * @param {Shape} element\n *\n * @return {Array<String>}\n */\n\n\nfunction getTakenConnectionAlignments(element) {\n  var elementMid = getMid(element);\n  var takenAlignments = [].concat(element.incoming.map(function (c) {\n    return c.waypoints[c.waypoints.length - 2];\n  }), element.outgoing.map(function (c) {\n    return c.waypoints[1];\n  })).map(function (point) {\n    return getApproximateOrientation(elementMid, point);\n  });\n  return takenAlignments;\n}\n/**\n * Return the optimal label position around an element\n * or _undefined_, if none was found.\n *\n * @param  {Shape} element\n *\n * @return {String} positioning identifier\n */\n\n\nfunction getOptimalPosition(element) {\n  var labelMid = getMid(element.label);\n  var elementMid = getMid(element);\n  var labelOrientation = getApproximateOrientation(elementMid, labelMid);\n\n  if (!isAligned(labelOrientation)) {\n    return;\n  }\n\n  var takenAlignments = getTakenConnectionAlignments(element);\n\n  if (element.host) {\n    var takenHostAlignments = getTakenHostAlignments(element);\n    takenAlignments = takenAlignments.concat(takenHostAlignments);\n  }\n\n  var freeAlignments = ALIGNMENTS.filter(function (alignment) {\n    return takenAlignments.indexOf(alignment) === -1;\n  }); // NOTHING TO DO; label already aligned a.O.K.\n\n  if (freeAlignments.indexOf(labelOrientation) !== -1) {\n    return;\n  }\n\n  return freeAlignments[0];\n}\n\nfunction getApproximateOrientation(p0, p1) {\n  return getOrientation(p1, p0, 5);\n}\n\nfunction isAligned(orientation) {\n  return ALIGNMENTS.indexOf(orientation) !== -1;\n}","map":{"version":3,"sources":["/Users/believecreative/Kumar/bpmn/node_modules/bpmn-js/lib/features/modeling/behavior/AdaptiveLabelPositioningBehavior.js"],"names":["inherits","getOrientation","getMid","asTRBL","substract","hasExternalLabel","CommandInterceptor","ALIGNMENTS","ELEMENT_LABEL_DISTANCE","AdaptiveLabelPositioningBehavior","eventBus","modeling","call","postExecuted","event","context","connection","source","target","hints","createElementsBehavior","checkLabelAdjustment","shape","labelTarget","elements","forEach","element","optimalPosition","getOptimalPosition","adjustLabelPosition","orientation","elementMid","label","labelMid","parent","elementTrbl","newLabelMid","x","y","top","height","left","width","bottom","right","delta","moveShape","$inject","getTakenHostAlignments","hostElement","host","hostOrientation","freeAlignments","indexOf","split","takenAlignments","filter","alignment","getTakenConnectionAlignments","concat","incoming","map","c","waypoints","length","outgoing","point","getApproximateOrientation","labelOrientation","isAligned","takenHostAlignments","p0","p1"],"mappings":"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","sourcesContent":["import inherits from 'inherits';\n\nimport {\n  getOrientation,\n  getMid,\n  asTRBL\n} from 'diagram-js/lib/layout/LayoutUtil';\n\nimport {\n  substract\n} from 'diagram-js/lib/util/Math';\n\nimport {\n  hasExternalLabel\n} from '../../../util/LabelUtil';\n\nimport CommandInterceptor from 'diagram-js/lib/command/CommandInterceptor';\n\nvar ALIGNMENTS = [\n  'top',\n  'bottom',\n  'left',\n  'right'\n];\n\nvar ELEMENT_LABEL_DISTANCE = 10;\n\n/**\n * A component that makes sure that external labels are added\n * together with respective elements and properly updated (DI wise)\n * during move.\n *\n * @param {EventBus} eventBus\n * @param {Modeling} modeling\n */\nexport default function AdaptiveLabelPositioningBehavior(eventBus, modeling) {\n\n  CommandInterceptor.call(this, eventBus);\n\n  this.postExecuted([\n    'connection.create',\n    'connection.layout',\n    'connection.updateWaypoints'\n  ], function(event) {\n    var context = event.context,\n        connection = context.connection,\n        source = connection.source,\n        target = connection.target,\n        hints = context.hints || {};\n\n    if (hints.createElementsBehavior !== false) {\n      checkLabelAdjustment(source);\n      checkLabelAdjustment(target);\n    }\n  });\n\n\n  this.postExecuted([\n    'label.create'\n  ], function(event) {\n    var context = event.context,\n        shape = context.shape,\n        hints = context.hints || {};\n\n    if (hints.createElementsBehavior !== false) {\n      checkLabelAdjustment(shape.labelTarget);\n    }\n  });\n\n\n  this.postExecuted([\n    'elements.create'\n  ], function(event) {\n    var context = event.context,\n        elements = context.elements,\n        hints = context.hints || {};\n\n    if (hints.createElementsBehavior !== false) {\n      elements.forEach(function(element) {\n        checkLabelAdjustment(element);\n      });\n    }\n  });\n\n  function checkLabelAdjustment(element) {\n\n    // skip non-existing labels\n    if (!hasExternalLabel(element)) {\n      return;\n    }\n\n    var optimalPosition = getOptimalPosition(element);\n\n    // no optimal position found\n    if (!optimalPosition) {\n      return;\n    }\n\n    adjustLabelPosition(element, optimalPosition);\n  }\n\n  function adjustLabelPosition(element, orientation) {\n\n    var elementMid = getMid(element),\n        label = element.label,\n        labelMid = getMid(label);\n\n    // ignore labels that are being created\n    if (!label.parent) {\n      return;\n    }\n\n    var elementTrbl = asTRBL(element);\n\n    var newLabelMid;\n\n    switch (orientation) {\n    case 'top':\n      newLabelMid = {\n        x: elementMid.x,\n        y: elementTrbl.top - ELEMENT_LABEL_DISTANCE - label.height / 2\n      };\n\n      break;\n\n    case 'left':\n\n      newLabelMid = {\n        x: elementTrbl.left - ELEMENT_LABEL_DISTANCE - label.width / 2,\n        y: elementMid.y\n      };\n\n      break;\n\n    case 'bottom':\n\n      newLabelMid = {\n        x: elementMid.x,\n        y: elementTrbl.bottom + ELEMENT_LABEL_DISTANCE + label.height / 2\n      };\n\n      break;\n\n    case 'right':\n\n      newLabelMid = {\n        x: elementTrbl.right + ELEMENT_LABEL_DISTANCE + label.width / 2,\n        y: elementMid.y\n      };\n\n      break;\n    }\n\n    var delta = substract(newLabelMid, labelMid);\n\n    modeling.moveShape(label, delta);\n  }\n\n}\n\ninherits(AdaptiveLabelPositioningBehavior, CommandInterceptor);\n\nAdaptiveLabelPositioningBehavior.$inject = [\n  'eventBus',\n  'modeling'\n];\n\n\n// helpers //////////////////////\n\n/**\n * Return alignments which are taken by a boundary's host element\n *\n * @param {Shape} element\n *\n * @return {Array<String>}\n */\nfunction getTakenHostAlignments(element) {\n\n  var hostElement = element.host,\n      elementMid = getMid(element),\n      hostOrientation = getOrientation(elementMid, hostElement);\n\n  var freeAlignments;\n\n  // check whether there is a multi-orientation, e.g. 'top-left'\n  if (hostOrientation.indexOf('-') >= 0) {\n    freeAlignments = hostOrientation.split('-');\n  } else {\n    freeAlignments = [ hostOrientation ];\n  }\n\n  var takenAlignments = ALIGNMENTS.filter(function(alignment) {\n\n    return freeAlignments.indexOf(alignment) === -1;\n  });\n\n  return takenAlignments;\n\n}\n\n/**\n * Return alignments which are taken by related connections\n *\n * @param {Shape} element\n *\n * @return {Array<String>}\n */\nfunction getTakenConnectionAlignments(element) {\n\n  var elementMid = getMid(element);\n\n  var takenAlignments = [].concat(\n    element.incoming.map(function(c) {\n      return c.waypoints[c.waypoints.length - 2 ];\n    }),\n    element.outgoing.map(function(c) {\n      return c.waypoints[1];\n    })\n  ).map(function(point) {\n    return getApproximateOrientation(elementMid, point);\n  });\n\n  return takenAlignments;\n}\n\n/**\n * Return the optimal label position around an element\n * or _undefined_, if none was found.\n *\n * @param  {Shape} element\n *\n * @return {String} positioning identifier\n */\nfunction getOptimalPosition(element) {\n\n  var labelMid = getMid(element.label);\n\n  var elementMid = getMid(element);\n\n  var labelOrientation = getApproximateOrientation(elementMid, labelMid);\n\n  if (!isAligned(labelOrientation)) {\n    return;\n  }\n\n  var takenAlignments = getTakenConnectionAlignments(element);\n\n  if (element.host) {\n    var takenHostAlignments = getTakenHostAlignments(element);\n\n    takenAlignments = takenAlignments.concat(takenHostAlignments);\n  }\n\n  var freeAlignments = ALIGNMENTS.filter(function(alignment) {\n\n    return takenAlignments.indexOf(alignment) === -1;\n  });\n\n  // NOTHING TO DO; label already aligned a.O.K.\n  if (freeAlignments.indexOf(labelOrientation) !== -1) {\n    return;\n  }\n\n  return freeAlignments[0];\n}\n\nfunction getApproximateOrientation(p0, p1) {\n  return getOrientation(p1, p0, 5);\n}\n\nfunction isAligned(orientation) {\n  return ALIGNMENTS.indexOf(orientation) !== -1;\n}\n"]},"metadata":{},"sourceType":"module"}