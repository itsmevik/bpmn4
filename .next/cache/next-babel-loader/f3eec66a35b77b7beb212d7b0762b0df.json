{"ast":null,"code":"import { mid, setSnapped } from 'diagram-js/lib/features/snapping/SnapUtil';\nimport { isCmd } from 'diagram-js/lib/features/keyboard/KeyboardUtil';\nimport { getOrientation } from 'diagram-js/lib/layout/LayoutUtil';\nimport { is } from '../../util/ModelUtil';\nimport { isAny } from '../modeling/util/ModelingUtil';\nimport { some } from 'min-dash';\nvar HIGHER_PRIORITY = 1250;\nvar BOUNDARY_TO_HOST_THRESHOLD = 40;\nvar TARGET_BOUNDS_PADDING = 20,\n    TASK_BOUNDS_PADDING = 10;\nvar TARGET_CENTER_PADDING = 20;\nvar AXES = ['x', 'y'];\nvar abs = Math.abs;\n/**\r\n * Snap during connect.\r\n *\r\n * @param {EventBus} eventBus\r\n */\n\nexport default function BpmnConnectSnapping(eventBus) {\n  eventBus.on(['connect.hover', 'connect.move', 'connect.end'], HIGHER_PRIORITY, function (event) {\n    var context = event.context,\n        canExecute = context.canExecute,\n        start = context.start,\n        hover = context.hover,\n        source = context.source,\n        target = context.target; // do NOT snap on CMD\n\n    if (event.originalEvent && isCmd(event.originalEvent)) {\n      return;\n    }\n\n    if (!context.initialConnectionStart) {\n      context.initialConnectionStart = context.connectionStart;\n    } // snap hover\n\n\n    if (canExecute && hover) {\n      snapToShape(event, hover, getTargetBoundsPadding(hover));\n    }\n\n    if (hover && isAnyType(canExecute, ['bpmn:Association', 'bpmn:DataInputAssociation', 'bpmn:DataOutputAssociation', 'bpmn:SequenceFlow'])) {\n      context.connectionStart = mid(start); // snap hover\n\n      if (isAny(hover, ['bpmn:Event', 'bpmn:Gateway'])) {\n        snapToPosition(event, mid(hover));\n      } // snap hover\n\n\n      if (isAny(hover, ['bpmn:Task', 'bpmn:SubProcess'])) {\n        snapToTargetMid(event, hover);\n      } // snap source and target\n\n\n      if (is(source, 'bpmn:BoundaryEvent') && target === source.host) {\n        snapBoundaryEventLoop(event);\n      }\n    } else if (isType(canExecute, 'bpmn:MessageFlow')) {\n      if (is(start, 'bpmn:Event')) {\n        // snap start\n        context.connectionStart = mid(start);\n      }\n\n      if (is(hover, 'bpmn:Event')) {\n        // snap hover\n        snapToPosition(event, mid(hover));\n      }\n    } else {\n      // un-snap source\n      context.connectionStart = context.initialConnectionStart;\n    }\n  });\n}\nBpmnConnectSnapping.$inject = ['eventBus']; // helpers //////////\n// snap to target if event in target\n\nfunction snapToShape(event, target, padding) {\n  AXES.forEach(function (axis) {\n    var dimensionForAxis = getDimensionForAxis(axis, target);\n\n    if (event[axis] < target[axis] + padding) {\n      setSnapped(event, axis, target[axis] + padding);\n    } else if (event[axis] > target[axis] + dimensionForAxis - padding) {\n      setSnapped(event, axis, target[axis] + dimensionForAxis - padding);\n    }\n  });\n} // snap to target mid if event in target mid\n\n\nfunction snapToTargetMid(event, target) {\n  var targetMid = mid(target);\n  AXES.forEach(function (axis) {\n    if (isMid(event, target, axis)) {\n      setSnapped(event, axis, targetMid[axis]);\n    }\n  });\n} // snap to prevent loop overlapping boundary event\n\n\nfunction snapBoundaryEventLoop(event) {\n  var context = event.context,\n      source = context.source,\n      target = context.target;\n\n  if (isReverse(context)) {\n    return;\n  }\n\n  var sourceMid = mid(source),\n      orientation = getOrientation(sourceMid, target, -10),\n      axes = [];\n\n  if (/top|bottom/.test(orientation)) {\n    axes.push('x');\n  }\n\n  if (/left|right/.test(orientation)) {\n    axes.push('y');\n  }\n\n  axes.forEach(function (axis) {\n    var coordinate = event[axis],\n        newCoordinate;\n\n    if (abs(coordinate - sourceMid[axis]) < BOUNDARY_TO_HOST_THRESHOLD) {\n      if (coordinate > sourceMid[axis]) {\n        newCoordinate = sourceMid[axis] + BOUNDARY_TO_HOST_THRESHOLD;\n      } else {\n        newCoordinate = sourceMid[axis] - BOUNDARY_TO_HOST_THRESHOLD;\n      }\n\n      setSnapped(event, axis, newCoordinate);\n    }\n  });\n}\n\nfunction snapToPosition(event, position) {\n  setSnapped(event, 'x', position.x);\n  setSnapped(event, 'y', position.y);\n}\n\nfunction isType(attrs, type) {\n  return attrs && attrs.type === type;\n}\n\nfunction isAnyType(attrs, types) {\n  return some(types, function (type) {\n    return isType(attrs, type);\n  });\n}\n\nfunction getDimensionForAxis(axis, element) {\n  return axis === 'x' ? element.width : element.height;\n}\n\nfunction getTargetBoundsPadding(target) {\n  if (is(target, 'bpmn:Task')) {\n    return TASK_BOUNDS_PADDING;\n  } else {\n    return TARGET_BOUNDS_PADDING;\n  }\n}\n\nfunction isMid(event, target, axis) {\n  return event[axis] > target[axis] + TARGET_CENTER_PADDING && event[axis] < target[axis] + getDimensionForAxis(axis, target) - TARGET_CENTER_PADDING;\n}\n\nfunction isReverse(context) {\n  var hover = context.hover,\n      source = context.source;\n  return hover && source && hover === source;\n}","map":{"version":3,"sources":["/Users/believecreative/Kumar/bpmn/node_modules/bpmn-js/lib/features/snapping/BpmnConnectSnapping.js"],"names":["mid","setSnapped","isCmd","getOrientation","is","isAny","some","HIGHER_PRIORITY","BOUNDARY_TO_HOST_THRESHOLD","TARGET_BOUNDS_PADDING","TASK_BOUNDS_PADDING","TARGET_CENTER_PADDING","AXES","abs","Math","BpmnConnectSnapping","eventBus","on","event","context","canExecute","start","hover","source","target","originalEvent","initialConnectionStart","connectionStart","snapToShape","getTargetBoundsPadding","isAnyType","snapToPosition","snapToTargetMid","host","snapBoundaryEventLoop","isType","$inject","padding","forEach","axis","dimensionForAxis","getDimensionForAxis","targetMid","isMid","isReverse","sourceMid","orientation","axes","test","push","coordinate","newCoordinate","position","x","y","attrs","type","types","element","width","height"],"mappings":"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","sourcesContent":["import {\r\n  mid,\r\n  setSnapped\r\n} from 'diagram-js/lib/features/snapping/SnapUtil';\r\n\r\nimport { isCmd } from 'diagram-js/lib/features/keyboard/KeyboardUtil';\r\n\r\nimport {\r\n  getOrientation\r\n} from 'diagram-js/lib/layout/LayoutUtil';\r\n\r\nimport { is } from '../../util/ModelUtil';\r\n\r\nimport { isAny } from '../modeling/util/ModelingUtil';\r\n\r\nimport { some } from 'min-dash';\r\n\r\nvar HIGHER_PRIORITY = 1250;\r\n\r\nvar BOUNDARY_TO_HOST_THRESHOLD = 40;\r\n\r\nvar TARGET_BOUNDS_PADDING = 20,\r\n    TASK_BOUNDS_PADDING = 10;\r\n\r\nvar TARGET_CENTER_PADDING = 20;\r\n\r\nvar AXES = [ 'x', 'y' ];\r\n\r\nvar abs = Math.abs;\r\n\r\n/**\r\n * Snap during connect.\r\n *\r\n * @param {EventBus} eventBus\r\n */\r\nexport default function BpmnConnectSnapping(eventBus) {\r\n  eventBus.on([\r\n    'connect.hover',\r\n    'connect.move',\r\n    'connect.end',\r\n  ], HIGHER_PRIORITY, function(event) {\r\n    var context = event.context,\r\n        canExecute = context.canExecute,\r\n        start = context.start,\r\n        hover = context.hover,\r\n        source = context.source,\r\n        target = context.target;\r\n\r\n    // do NOT snap on CMD\r\n    if (event.originalEvent && isCmd(event.originalEvent)) {\r\n      return;\r\n    }\r\n\r\n    if (!context.initialConnectionStart) {\r\n      context.initialConnectionStart = context.connectionStart;\r\n    }\r\n\r\n    // snap hover\r\n    if (canExecute && hover) {\r\n      snapToShape(event, hover, getTargetBoundsPadding(hover));\r\n    }\r\n\r\n    if (hover && isAnyType(canExecute, [\r\n      'bpmn:Association',\r\n      'bpmn:DataInputAssociation',\r\n      'bpmn:DataOutputAssociation',\r\n      'bpmn:SequenceFlow'\r\n    ])) {\r\n      context.connectionStart = mid(start);\r\n\r\n      // snap hover\r\n      if (isAny(hover, [ 'bpmn:Event', 'bpmn:Gateway' ])) {\r\n        snapToPosition(event, mid(hover));\r\n      }\r\n\r\n      // snap hover\r\n      if (isAny(hover, [ 'bpmn:Task', 'bpmn:SubProcess' ])) {\r\n        snapToTargetMid(event, hover);\r\n      }\r\n\r\n      // snap source and target\r\n      if (is(source, 'bpmn:BoundaryEvent') && target === source.host) {\r\n        snapBoundaryEventLoop(event);\r\n      }\r\n\r\n    } else if (isType(canExecute, 'bpmn:MessageFlow')) {\r\n\r\n      if (is(start, 'bpmn:Event')) {\r\n\r\n        // snap start\r\n        context.connectionStart = mid(start);\r\n      }\r\n\r\n      if (is(hover, 'bpmn:Event')) {\r\n\r\n        // snap hover\r\n        snapToPosition(event, mid(hover));\r\n      }\r\n\r\n    } else {\r\n\r\n      // un-snap source\r\n      context.connectionStart = context.initialConnectionStart;\r\n    }\r\n  });\r\n}\r\n\r\nBpmnConnectSnapping.$inject = [ 'eventBus' ];\r\n\r\n\r\n// helpers //////////\r\n\r\n// snap to target if event in target\r\nfunction snapToShape(event, target, padding) {\r\n  AXES.forEach(function(axis) {\r\n    var dimensionForAxis = getDimensionForAxis(axis, target);\r\n\r\n    if (event[ axis ] < target[ axis ] + padding) {\r\n      setSnapped(event, axis, target[ axis ] + padding);\r\n    } else if (event[ axis ] > target[ axis ] + dimensionForAxis - padding) {\r\n      setSnapped(event, axis, target[ axis ] + dimensionForAxis - padding);\r\n    }\r\n  });\r\n}\r\n\r\n// snap to target mid if event in target mid\r\nfunction snapToTargetMid(event, target) {\r\n  var targetMid = mid(target);\r\n\r\n  AXES.forEach(function(axis) {\r\n    if (isMid(event, target, axis)) {\r\n      setSnapped(event, axis, targetMid[ axis ]);\r\n    }\r\n  });\r\n}\r\n\r\n// snap to prevent loop overlapping boundary event\r\nfunction snapBoundaryEventLoop(event) {\r\n  var context = event.context,\r\n      source = context.source,\r\n      target = context.target;\r\n\r\n  if (isReverse(context)) {\r\n    return;\r\n  }\r\n\r\n  var sourceMid = mid(source),\r\n      orientation = getOrientation(sourceMid, target, -10),\r\n      axes = [];\r\n\r\n  if (/top|bottom/.test(orientation)) {\r\n    axes.push('x');\r\n  }\r\n\r\n  if (/left|right/.test(orientation)) {\r\n    axes.push('y');\r\n  }\r\n\r\n  axes.forEach(function(axis) {\r\n    var coordinate = event[ axis ], newCoordinate;\r\n\r\n    if (abs(coordinate - sourceMid[ axis ]) < BOUNDARY_TO_HOST_THRESHOLD) {\r\n      if (coordinate > sourceMid[ axis ]) {\r\n        newCoordinate = sourceMid[ axis ] + BOUNDARY_TO_HOST_THRESHOLD;\r\n      }\r\n      else {\r\n        newCoordinate = sourceMid[ axis ] - BOUNDARY_TO_HOST_THRESHOLD;\r\n      }\r\n\r\n      setSnapped(event, axis, newCoordinate);\r\n    }\r\n  });\r\n}\r\n\r\nfunction snapToPosition(event, position) {\r\n  setSnapped(event, 'x', position.x);\r\n  setSnapped(event, 'y', position.y);\r\n}\r\n\r\nfunction isType(attrs, type) {\r\n  return attrs && attrs.type === type;\r\n}\r\n\r\nfunction isAnyType(attrs, types) {\r\n  return some(types, function(type) {\r\n    return isType(attrs, type);\r\n  });\r\n}\r\n\r\nfunction getDimensionForAxis(axis, element) {\r\n  return axis === 'x' ? element.width : element.height;\r\n}\r\n\r\nfunction getTargetBoundsPadding(target) {\r\n  if (is(target, 'bpmn:Task')) {\r\n    return TASK_BOUNDS_PADDING;\r\n  } else {\r\n    return TARGET_BOUNDS_PADDING;\r\n  }\r\n}\r\n\r\nfunction isMid(event, target, axis) {\r\n  return event[ axis ] > target[ axis ] + TARGET_CENTER_PADDING\r\n    && event[ axis ] < target[ axis ] + getDimensionForAxis(axis, target) - TARGET_CENTER_PADDING;\r\n}\r\n\r\nfunction isReverse(context) {\r\n  var hover = context.hover,\r\n      source = context.source;\r\n\r\n  return hover && source && hover === source;\r\n}"]},"metadata":{},"sourceType":"module"}