{"ast":null,"code":"import { collectLanes, getLanesRoot } from '../util/LaneUtil';\nimport { is } from '../../../util/ModelUtil';\nimport { add as collectionAdd, remove as collectionRemove } from 'diagram-js/lib/util/Collections';\nimport { asTRBL } from 'diagram-js/lib/layout/LayoutUtil';\nvar FLOW_NODE_REFS_ATTR = 'flowNodeRef',\n    LANES_ATTR = 'lanes';\n/**\n * A handler that updates lane refs on changed elements\n */\n\nexport default function UpdateFlowNodeRefsHandler(elementRegistry) {\n  this._elementRegistry = elementRegistry;\n}\nUpdateFlowNodeRefsHandler.$inject = ['elementRegistry'];\n\nUpdateFlowNodeRefsHandler.prototype.computeUpdates = function (flowNodeShapes, laneShapes) {\n  var handledNodes = [];\n  var updates = [];\n  var participantCache = {};\n  var allFlowNodeShapes = [];\n\n  function isInLaneShape(element, laneShape) {\n    var laneTrbl = asTRBL(laneShape);\n    var elementMid = {\n      x: element.x + element.width / 2,\n      y: element.y + element.height / 2\n    };\n    return elementMid.x > laneTrbl.left && elementMid.x < laneTrbl.right && elementMid.y > laneTrbl.top && elementMid.y < laneTrbl.bottom;\n  }\n\n  function addFlowNodeShape(flowNodeShape) {\n    if (handledNodes.indexOf(flowNodeShape) === -1) {\n      allFlowNodeShapes.push(flowNodeShape);\n      handledNodes.push(flowNodeShape);\n    }\n  }\n\n  function getAllLaneShapes(flowNodeShape) {\n    var root = getLanesRoot(flowNodeShape);\n\n    if (!participantCache[root.id]) {\n      participantCache[root.id] = collectLanes(root);\n    }\n\n    return participantCache[root.id];\n  }\n\n  function getNewLanes(flowNodeShape) {\n    if (!flowNodeShape.parent) {\n      return [];\n    }\n\n    var allLaneShapes = getAllLaneShapes(flowNodeShape);\n    return allLaneShapes.filter(function (l) {\n      return isInLaneShape(flowNodeShape, l);\n    }).map(function (shape) {\n      return shape.businessObject;\n    });\n  }\n\n  laneShapes.forEach(function (laneShape) {\n    var root = getLanesRoot(laneShape);\n\n    if (!root || handledNodes.indexOf(root) !== -1) {\n      return;\n    }\n\n    var children = root.children.filter(function (c) {\n      return is(c, 'bpmn:FlowNode');\n    });\n    children.forEach(addFlowNodeShape);\n    handledNodes.push(root);\n  });\n  flowNodeShapes.forEach(addFlowNodeShape);\n  allFlowNodeShapes.forEach(function (flowNodeShape) {\n    var flowNode = flowNodeShape.businessObject;\n    var lanes = flowNode.get(LANES_ATTR),\n        remove = lanes.slice(),\n        add = getNewLanes(flowNodeShape);\n    updates.push({\n      flowNode: flowNode,\n      remove: remove,\n      add: add\n    });\n  });\n  laneShapes.forEach(function (laneShape) {\n    var lane = laneShape.businessObject; // lane got removed XX-)\n\n    if (!laneShape.parent) {\n      lane.get(FLOW_NODE_REFS_ATTR).forEach(function (flowNode) {\n        updates.push({\n          flowNode: flowNode,\n          remove: [lane],\n          add: []\n        });\n      });\n    }\n  });\n  return updates;\n};\n\nUpdateFlowNodeRefsHandler.prototype.execute = function (context) {\n  var updates = context.updates;\n\n  if (!updates) {\n    updates = context.updates = this.computeUpdates(context.flowNodeShapes, context.laneShapes);\n  }\n\n  updates.forEach(function (update) {\n    var flowNode = update.flowNode,\n        lanes = flowNode.get(LANES_ATTR); // unwire old\n\n    update.remove.forEach(function (oldLane) {\n      collectionRemove(lanes, oldLane);\n      collectionRemove(oldLane.get(FLOW_NODE_REFS_ATTR), flowNode);\n    }); // wire new\n\n    update.add.forEach(function (newLane) {\n      collectionAdd(lanes, newLane);\n      collectionAdd(newLane.get(FLOW_NODE_REFS_ATTR), flowNode);\n    });\n  }); // TODO(nikku): return changed elements\n  // return [ ... ];\n};\n\nUpdateFlowNodeRefsHandler.prototype.revert = function (context) {\n  var updates = context.updates;\n  updates.forEach(function (update) {\n    var flowNode = update.flowNode,\n        lanes = flowNode.get(LANES_ATTR); // unwire new\n\n    update.add.forEach(function (newLane) {\n      collectionRemove(lanes, newLane);\n      collectionRemove(newLane.get(FLOW_NODE_REFS_ATTR), flowNode);\n    }); // wire old\n\n    update.remove.forEach(function (oldLane) {\n      collectionAdd(lanes, oldLane);\n      collectionAdd(oldLane.get(FLOW_NODE_REFS_ATTR), flowNode);\n    });\n  }); // TODO(nikku): return changed elements\n  // return [ ... ];\n};","map":{"version":3,"sources":["/Users/believecreative/Kumar/bpmn/node_modules/bpmn-js/lib/features/modeling/cmd/UpdateFlowNodeRefsHandler.js"],"names":["collectLanes","getLanesRoot","is","add","collectionAdd","remove","collectionRemove","asTRBL","FLOW_NODE_REFS_ATTR","LANES_ATTR","UpdateFlowNodeRefsHandler","elementRegistry","_elementRegistry","$inject","prototype","computeUpdates","flowNodeShapes","laneShapes","handledNodes","updates","participantCache","allFlowNodeShapes","isInLaneShape","element","laneShape","laneTrbl","elementMid","x","width","y","height","left","right","top","bottom","addFlowNodeShape","flowNodeShape","indexOf","push","getAllLaneShapes","root","id","getNewLanes","parent","allLaneShapes","filter","l","map","shape","businessObject","forEach","children","c","flowNode","lanes","get","slice","lane","execute","context","update","oldLane","newLane","revert"],"mappings":"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","sourcesContent":["import {\n  collectLanes,\n  getLanesRoot\n} from '../util/LaneUtil';\n\nimport {\n  is\n} from '../../../util/ModelUtil';\n\nimport {\n  add as collectionAdd,\n  remove as collectionRemove\n} from 'diagram-js/lib/util/Collections';\n\nimport {\n  asTRBL\n} from 'diagram-js/lib/layout/LayoutUtil';\n\nvar FLOW_NODE_REFS_ATTR = 'flowNodeRef',\n    LANES_ATTR = 'lanes';\n\n\n/**\n * A handler that updates lane refs on changed elements\n */\nexport default function UpdateFlowNodeRefsHandler(elementRegistry) {\n  this._elementRegistry = elementRegistry;\n}\n\nUpdateFlowNodeRefsHandler.$inject = [\n  'elementRegistry'\n];\n\n\nUpdateFlowNodeRefsHandler.prototype.computeUpdates = function(flowNodeShapes, laneShapes) {\n\n  var handledNodes = [];\n\n  var updates = [];\n\n  var participantCache = {};\n\n  var allFlowNodeShapes = [];\n\n  function isInLaneShape(element, laneShape) {\n\n    var laneTrbl = asTRBL(laneShape);\n\n    var elementMid = {\n      x: element.x + element.width / 2,\n      y: element.y + element.height / 2\n    };\n\n    return elementMid.x > laneTrbl.left &&\n           elementMid.x < laneTrbl.right &&\n           elementMid.y > laneTrbl.top &&\n           elementMid.y < laneTrbl.bottom;\n  }\n\n  function addFlowNodeShape(flowNodeShape) {\n    if (handledNodes.indexOf(flowNodeShape) === -1) {\n      allFlowNodeShapes.push(flowNodeShape);\n      handledNodes.push(flowNodeShape);\n    }\n  }\n\n  function getAllLaneShapes(flowNodeShape) {\n\n    var root = getLanesRoot(flowNodeShape);\n\n    if (!participantCache[root.id]) {\n      participantCache[root.id] = collectLanes(root);\n    }\n\n    return participantCache[root.id];\n  }\n\n  function getNewLanes(flowNodeShape) {\n    if (!flowNodeShape.parent) {\n      return [];\n    }\n\n    var allLaneShapes = getAllLaneShapes(flowNodeShape);\n\n    return allLaneShapes.filter(function(l) {\n      return isInLaneShape(flowNodeShape, l);\n    }).map(function(shape) {\n      return shape.businessObject;\n    });\n  }\n\n  laneShapes.forEach(function(laneShape) {\n    var root = getLanesRoot(laneShape);\n\n    if (!root || handledNodes.indexOf(root) !== -1) {\n      return;\n    }\n\n    var children = root.children.filter(function(c) {\n      return is(c, 'bpmn:FlowNode');\n    });\n\n    children.forEach(addFlowNodeShape);\n\n    handledNodes.push(root);\n  });\n\n  flowNodeShapes.forEach(addFlowNodeShape);\n\n\n  allFlowNodeShapes.forEach(function(flowNodeShape) {\n\n    var flowNode = flowNodeShape.businessObject;\n\n    var lanes = flowNode.get(LANES_ATTR),\n        remove = lanes.slice(),\n        add = getNewLanes(flowNodeShape);\n\n    updates.push({ flowNode: flowNode, remove: remove, add: add });\n  });\n\n  laneShapes.forEach(function(laneShape) {\n\n    var lane = laneShape.businessObject;\n\n    // lane got removed XX-)\n    if (!laneShape.parent) {\n      lane.get(FLOW_NODE_REFS_ATTR).forEach(function(flowNode) {\n        updates.push({ flowNode: flowNode, remove: [ lane ], add: [] });\n      });\n    }\n  });\n\n  return updates;\n};\n\nUpdateFlowNodeRefsHandler.prototype.execute = function(context) {\n\n  var updates = context.updates;\n\n  if (!updates) {\n    updates = context.updates = this.computeUpdates(context.flowNodeShapes, context.laneShapes);\n  }\n\n\n  updates.forEach(function(update) {\n\n    var flowNode = update.flowNode,\n        lanes = flowNode.get(LANES_ATTR);\n\n    // unwire old\n    update.remove.forEach(function(oldLane) {\n      collectionRemove(lanes, oldLane);\n      collectionRemove(oldLane.get(FLOW_NODE_REFS_ATTR), flowNode);\n    });\n\n    // wire new\n    update.add.forEach(function(newLane) {\n      collectionAdd(lanes, newLane);\n      collectionAdd(newLane.get(FLOW_NODE_REFS_ATTR), flowNode);\n    });\n  });\n\n  // TODO(nikku): return changed elements\n  // return [ ... ];\n};\n\n\nUpdateFlowNodeRefsHandler.prototype.revert = function(context) {\n\n  var updates = context.updates;\n\n  updates.forEach(function(update) {\n\n    var flowNode = update.flowNode,\n        lanes = flowNode.get(LANES_ATTR);\n\n    // unwire new\n    update.add.forEach(function(newLane) {\n      collectionRemove(lanes, newLane);\n      collectionRemove(newLane.get(FLOW_NODE_REFS_ATTR), flowNode);\n    });\n\n    // wire old\n    update.remove.forEach(function(oldLane) {\n      collectionAdd(lanes, oldLane);\n      collectionAdd(oldLane.get(FLOW_NODE_REFS_ATTR), flowNode);\n    });\n  });\n\n  // TODO(nikku): return changed elements\n  // return [ ... ];\n};\n"]},"metadata":{},"sourceType":"module"}