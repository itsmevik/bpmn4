{"ast":null,"code":"import { assign } from 'min-dash';\nimport inherits from 'inherits';\nimport { is, getBusinessObject } from '../../../util/ModelUtil';\nimport { isLabelExternal, getExternalLabelMid, hasExternalLabel, isLabel } from '../../../util/LabelUtil';\nimport { getLabel } from '../../label-editing/LabelUtil';\nimport { getLabelAdjustment } from './util/LabelLayoutUtil';\nimport CommandInterceptor from 'diagram-js/lib/command/CommandInterceptor';\nimport { getNewAttachPoint } from 'diagram-js/lib/util/AttachUtil';\nimport { getMid, roundPoint } from 'diagram-js/lib/layout/LayoutUtil';\nimport { delta } from 'diagram-js/lib/util/PositionUtil';\nimport { sortBy } from 'min-dash';\nimport { getDistancePointLine, perpendicularFoot } from './util/GeometricUtil';\nvar DEFAULT_LABEL_DIMENSIONS = {\n  width: 90,\n  height: 20\n};\nvar NAME_PROPERTY = 'name';\nvar TEXT_PROPERTY = 'text';\n/**\n * A component that makes sure that external labels are added\n * together with respective elements and properly updated (DI wise)\n * during move.\n *\n * @param {EventBus} eventBus\n * @param {Modeling} modeling\n * @param {BpmnFactory} bpmnFactory\n * @param {TextRenderer} textRenderer\n */\n\nexport default function LabelBehavior(eventBus, modeling, bpmnFactory, textRenderer) {\n  CommandInterceptor.call(this, eventBus); // update label if name property was updated\n\n  this.postExecute('element.updateProperties', function (e) {\n    var context = e.context,\n        element = context.element,\n        properties = context.properties;\n\n    if (NAME_PROPERTY in properties) {\n      modeling.updateLabel(element, properties[NAME_PROPERTY]);\n    }\n\n    if (TEXT_PROPERTY in properties && is(element, 'bpmn:TextAnnotation')) {\n      var newBounds = textRenderer.getTextAnnotationBounds({\n        x: element.x,\n        y: element.y,\n        width: element.width,\n        height: element.height\n      }, properties[TEXT_PROPERTY] || '');\n      modeling.updateLabel(element, properties.text, newBounds);\n    }\n  }); // create label shape after shape/connection was created\n\n  this.postExecute(['shape.create', 'connection.create'], function (e) {\n    var context = e.context,\n        hints = context.hints || {};\n\n    if (hints.createElementsBehavior === false) {\n      return;\n    }\n\n    var element = context.shape || context.connection,\n        businessObject = element.businessObject;\n\n    if (isLabel(element) || !isLabelExternal(element)) {\n      return;\n    } // only create label if attribute available\n\n\n    if (!getLabel(element)) {\n      return;\n    }\n\n    var labelCenter = getExternalLabelMid(element); // we don't care about x and y\n\n    var labelDimensions = textRenderer.getExternalLabelBounds(DEFAULT_LABEL_DIMENSIONS, getLabel(element));\n    modeling.createLabel(element, labelCenter, {\n      id: businessObject.id + '_label',\n      businessObject: businessObject,\n      width: labelDimensions.width,\n      height: labelDimensions.height\n    });\n  }); // update label after label shape was deleted\n\n  this.postExecute('shape.delete', function (event) {\n    var context = event.context,\n        labelTarget = context.labelTarget,\n        hints = context.hints || {}; // check if label\n\n    if (labelTarget && hints.unsetLabel !== false) {\n      modeling.updateLabel(labelTarget, null, null, {\n        removeShape: false\n      });\n    }\n  }); // update di information on label creation\n\n  this.postExecute(['label.create'], function (event) {\n    var context = event.context,\n        element = context.shape,\n        businessObject,\n        di; // we want to trigger on real labels only\n\n    if (!element.labelTarget) {\n      return;\n    } // we want to trigger on BPMN elements only\n\n\n    if (!is(element.labelTarget || element, 'bpmn:BaseElement')) {\n      return;\n    }\n\n    businessObject = element.businessObject, di = businessObject.di;\n\n    if (!di.label) {\n      di.label = bpmnFactory.create('bpmndi:BPMNLabel', {\n        bounds: bpmnFactory.create('dc:Bounds')\n      });\n    }\n\n    assign(di.label.bounds, {\n      x: element.x,\n      y: element.y,\n      width: element.width,\n      height: element.height\n    });\n  });\n\n  function getVisibleLabelAdjustment(event) {\n    var context = event.context,\n        connection = context.connection,\n        label = connection.label,\n        hints = assign({}, context.hints),\n        newWaypoints = context.newWaypoints || connection.waypoints,\n        oldWaypoints = context.oldWaypoints;\n\n    if (typeof hints.startChanged === 'undefined') {\n      hints.startChanged = !!hints.connectionStart;\n    }\n\n    if (typeof hints.endChanged === 'undefined') {\n      hints.endChanged = !!hints.connectionEnd;\n    }\n\n    return getLabelAdjustment(label, newWaypoints, oldWaypoints, hints);\n  }\n\n  this.postExecute(['connection.layout', 'connection.updateWaypoints'], function (event) {\n    var context = event.context,\n        hints = context.hints || {};\n\n    if (hints.labelBehavior === false) {\n      return;\n    }\n\n    var connection = context.connection,\n        label = connection.label,\n        labelAdjustment; // handle missing label as well as the case\n    // that the label parent does not exist (yet),\n    // because it is being pasted / created via multi element create\n    //\n    // Cf. https://github.com/bpmn-io/bpmn-js/pull/1227\n\n    if (!label || !label.parent) {\n      return;\n    }\n\n    labelAdjustment = getVisibleLabelAdjustment(event);\n    modeling.moveShape(label, labelAdjustment);\n  }); // keep label position on shape replace\n\n  this.postExecute(['shape.replace'], function (event) {\n    var context = event.context,\n        newShape = context.newShape,\n        oldShape = context.oldShape;\n    var businessObject = getBusinessObject(newShape);\n\n    if (businessObject && isLabelExternal(businessObject) && oldShape.label && newShape.label) {\n      newShape.label.x = oldShape.label.x;\n      newShape.label.y = oldShape.label.y;\n    }\n  }); // move external label after resizing\n\n  this.postExecute('shape.resize', function (event) {\n    var context = event.context,\n        shape = context.shape,\n        newBounds = context.newBounds,\n        oldBounds = context.oldBounds;\n\n    if (hasExternalLabel(shape)) {\n      var label = shape.label,\n          labelMid = getMid(label),\n          edges = asEdges(oldBounds); // get nearest border point to label as reference point\n\n      var referencePoint = getReferencePoint(labelMid, edges);\n      var delta = getReferencePointDelta(referencePoint, oldBounds, newBounds);\n      modeling.moveShape(label, delta);\n    }\n  });\n}\ninherits(LabelBehavior, CommandInterceptor);\nLabelBehavior.$inject = ['eventBus', 'modeling', 'bpmnFactory', 'textRenderer']; // helpers //////////////////////\n\n/**\n * Calculates a reference point delta relative to a new position\n * of a certain element's bounds\n *\n * @param {Point} point\n * @param {Bounds} oldBounds\n * @param {Bounds} newBounds\n *\n * @return {Delta} delta\n */\n\nexport function getReferencePointDelta(referencePoint, oldBounds, newBounds) {\n  var newReferencePoint = getNewAttachPoint(referencePoint, oldBounds, newBounds);\n  return roundPoint(delta(newReferencePoint, referencePoint));\n}\n/**\n * Generates the nearest point (reference point) for a given point\n * onto given set of lines\n *\n * @param {Array<Point, Point>} lines\n * @param {Point} point\n *\n * @param {Point}\n */\n\nexport function getReferencePoint(point, lines) {\n  if (!lines.length) {\n    return;\n  }\n\n  var nearestLine = getNearestLine(point, lines);\n  return perpendicularFoot(point, nearestLine);\n}\n/**\n * Convert the given bounds to a lines array containing all edges\n *\n * @param {Bounds|Point} bounds\n *\n * @return Array<Point>\n */\n\nexport function asEdges(bounds) {\n  return [[// top\n  {\n    x: bounds.x,\n    y: bounds.y\n  }, {\n    x: bounds.x + (bounds.width || 0),\n    y: bounds.y\n  }], [// right\n  {\n    x: bounds.x + (bounds.width || 0),\n    y: bounds.y\n  }, {\n    x: bounds.x + (bounds.width || 0),\n    y: bounds.y + (bounds.height || 0)\n  }], [// bottom\n  {\n    x: bounds.x,\n    y: bounds.y + (bounds.height || 0)\n  }, {\n    x: bounds.x + (bounds.width || 0),\n    y: bounds.y + (bounds.height || 0)\n  }], [// left\n  {\n    x: bounds.x,\n    y: bounds.y\n  }, {\n    x: bounds.x,\n    y: bounds.y + (bounds.height || 0)\n  }]];\n}\n/**\n * Returns the nearest line for a given point by distance\n * @param {Point} point\n * @param Array<Point> lines\n *\n * @return Array<Point>\n */\n\nfunction getNearestLine(point, lines) {\n  var distances = lines.map(function (l) {\n    return {\n      line: l,\n      distance: getDistancePointLine(point, l)\n    };\n  });\n  var sorted = sortBy(distances, 'distance');\n  return sorted[0].line;\n}","map":{"version":3,"sources":["/Users/believecreative/Kumar/bpmn/node_modules/bpmn-js/lib/features/modeling/behavior/LabelBehavior.js"],"names":["assign","inherits","is","getBusinessObject","isLabelExternal","getExternalLabelMid","hasExternalLabel","isLabel","getLabel","getLabelAdjustment","CommandInterceptor","getNewAttachPoint","getMid","roundPoint","delta","sortBy","getDistancePointLine","perpendicularFoot","DEFAULT_LABEL_DIMENSIONS","width","height","NAME_PROPERTY","TEXT_PROPERTY","LabelBehavior","eventBus","modeling","bpmnFactory","textRenderer","call","postExecute","e","context","element","properties","updateLabel","newBounds","getTextAnnotationBounds","x","y","text","hints","createElementsBehavior","shape","connection","businessObject","labelCenter","labelDimensions","getExternalLabelBounds","createLabel","id","event","labelTarget","unsetLabel","removeShape","di","label","create","bounds","getVisibleLabelAdjustment","newWaypoints","waypoints","oldWaypoints","startChanged","connectionStart","endChanged","connectionEnd","labelBehavior","labelAdjustment","parent","moveShape","newShape","oldShape","oldBounds","labelMid","edges","asEdges","referencePoint","getReferencePoint","getReferencePointDelta","$inject","newReferencePoint","point","lines","length","nearestLine","getNearestLine","distances","map","l","line","distance","sorted"],"mappings":"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","sourcesContent":["import {\n  assign\n} from 'min-dash';\n\nimport inherits from 'inherits';\n\nimport {\n  is,\n  getBusinessObject\n} from '../../../util/ModelUtil';\n\nimport {\n  isLabelExternal,\n  getExternalLabelMid,\n  hasExternalLabel,\n  isLabel\n} from '../../../util/LabelUtil';\n\nimport {\n  getLabel\n} from '../../label-editing/LabelUtil';\n\nimport {\n  getLabelAdjustment\n} from './util/LabelLayoutUtil';\n\nimport CommandInterceptor from 'diagram-js/lib/command/CommandInterceptor';\n\nimport {\n  getNewAttachPoint\n} from 'diagram-js/lib/util/AttachUtil';\n\nimport {\n  getMid,\n  roundPoint\n} from 'diagram-js/lib/layout/LayoutUtil';\n\nimport {\n  delta\n} from 'diagram-js/lib/util/PositionUtil';\n\nimport {\n  sortBy\n} from 'min-dash';\n\nimport {\n  getDistancePointLine,\n  perpendicularFoot\n} from './util/GeometricUtil';\n\nvar DEFAULT_LABEL_DIMENSIONS = {\n  width: 90,\n  height: 20\n};\n\nvar NAME_PROPERTY = 'name';\nvar TEXT_PROPERTY = 'text';\n\n/**\n * A component that makes sure that external labels are added\n * together with respective elements and properly updated (DI wise)\n * during move.\n *\n * @param {EventBus} eventBus\n * @param {Modeling} modeling\n * @param {BpmnFactory} bpmnFactory\n * @param {TextRenderer} textRenderer\n */\nexport default function LabelBehavior(\n    eventBus, modeling, bpmnFactory,\n    textRenderer) {\n\n  CommandInterceptor.call(this, eventBus);\n\n  // update label if name property was updated\n  this.postExecute('element.updateProperties', function(e) {\n    var context = e.context,\n        element = context.element,\n        properties = context.properties;\n\n    if (NAME_PROPERTY in properties) {\n      modeling.updateLabel(element, properties[NAME_PROPERTY]);\n    }\n\n    if (TEXT_PROPERTY in properties\n        && is(element, 'bpmn:TextAnnotation')) {\n\n      var newBounds = textRenderer.getTextAnnotationBounds(\n        {\n          x: element.x,\n          y: element.y,\n          width: element.width,\n          height: element.height\n        },\n        properties[TEXT_PROPERTY] || ''\n      );\n\n      modeling.updateLabel(element, properties.text, newBounds);\n    }\n  });\n\n  // create label shape after shape/connection was created\n  this.postExecute([ 'shape.create', 'connection.create' ], function(e) {\n    var context = e.context,\n        hints = context.hints || {};\n\n    if (hints.createElementsBehavior === false) {\n      return;\n    }\n\n    var element = context.shape || context.connection,\n        businessObject = element.businessObject;\n\n    if (isLabel(element) || !isLabelExternal(element)) {\n      return;\n    }\n\n    // only create label if attribute available\n    if (!getLabel(element)) {\n      return;\n    }\n\n    var labelCenter = getExternalLabelMid(element);\n\n    // we don't care about x and y\n    var labelDimensions = textRenderer.getExternalLabelBounds(\n      DEFAULT_LABEL_DIMENSIONS,\n      getLabel(element)\n    );\n\n    modeling.createLabel(element, labelCenter, {\n      id: businessObject.id + '_label',\n      businessObject: businessObject,\n      width: labelDimensions.width,\n      height: labelDimensions.height\n    });\n  });\n\n  // update label after label shape was deleted\n  this.postExecute('shape.delete', function(event) {\n    var context = event.context,\n        labelTarget = context.labelTarget,\n        hints = context.hints || {};\n\n    // check if label\n    if (labelTarget && hints.unsetLabel !== false) {\n      modeling.updateLabel(labelTarget, null, null, { removeShape: false });\n    }\n  });\n\n  // update di information on label creation\n  this.postExecute([ 'label.create' ], function(event) {\n\n    var context = event.context,\n        element = context.shape,\n        businessObject,\n        di;\n\n    // we want to trigger on real labels only\n    if (!element.labelTarget) {\n      return;\n    }\n\n    // we want to trigger on BPMN elements only\n    if (!is(element.labelTarget || element, 'bpmn:BaseElement')) {\n      return;\n    }\n\n    businessObject = element.businessObject,\n    di = businessObject.di;\n\n\n    if (!di.label) {\n      di.label = bpmnFactory.create('bpmndi:BPMNLabel', {\n        bounds: bpmnFactory.create('dc:Bounds')\n      });\n    }\n\n    assign(di.label.bounds, {\n      x: element.x,\n      y: element.y,\n      width: element.width,\n      height: element.height\n    });\n  });\n\n  function getVisibleLabelAdjustment(event) {\n\n    var context = event.context,\n        connection = context.connection,\n        label = connection.label,\n        hints = assign({}, context.hints),\n        newWaypoints = context.newWaypoints || connection.waypoints,\n        oldWaypoints = context.oldWaypoints;\n\n\n    if (typeof hints.startChanged === 'undefined') {\n      hints.startChanged = !!hints.connectionStart;\n    }\n\n    if (typeof hints.endChanged === 'undefined') {\n      hints.endChanged = !!hints.connectionEnd;\n    }\n\n    return getLabelAdjustment(label, newWaypoints, oldWaypoints, hints);\n  }\n\n  this.postExecute([\n    'connection.layout',\n    'connection.updateWaypoints'\n  ], function(event) {\n    var context = event.context,\n        hints = context.hints || {};\n\n    if (hints.labelBehavior === false) {\n      return;\n    }\n\n    var connection = context.connection,\n        label = connection.label,\n        labelAdjustment;\n\n    // handle missing label as well as the case\n    // that the label parent does not exist (yet),\n    // because it is being pasted / created via multi element create\n    //\n    // Cf. https://github.com/bpmn-io/bpmn-js/pull/1227\n    if (!label || !label.parent) {\n      return;\n    }\n\n    labelAdjustment = getVisibleLabelAdjustment(event);\n\n    modeling.moveShape(label, labelAdjustment);\n  });\n\n\n  // keep label position on shape replace\n  this.postExecute([ 'shape.replace' ], function(event) {\n    var context = event.context,\n        newShape = context.newShape,\n        oldShape = context.oldShape;\n\n    var businessObject = getBusinessObject(newShape);\n\n    if (businessObject\n      && isLabelExternal(businessObject)\n      && oldShape.label\n      && newShape.label) {\n      newShape.label.x = oldShape.label.x;\n      newShape.label.y = oldShape.label.y;\n    }\n  });\n\n\n  // move external label after resizing\n  this.postExecute('shape.resize', function(event) {\n\n    var context = event.context,\n        shape = context.shape,\n        newBounds = context.newBounds,\n        oldBounds = context.oldBounds;\n\n    if (hasExternalLabel(shape)) {\n\n      var label = shape.label,\n          labelMid = getMid(label),\n          edges = asEdges(oldBounds);\n\n      // get nearest border point to label as reference point\n      var referencePoint = getReferencePoint(labelMid, edges);\n\n      var delta = getReferencePointDelta(referencePoint, oldBounds, newBounds);\n\n      modeling.moveShape(label, delta);\n\n    }\n\n  });\n\n}\n\ninherits(LabelBehavior, CommandInterceptor);\n\nLabelBehavior.$inject = [\n  'eventBus',\n  'modeling',\n  'bpmnFactory',\n  'textRenderer'\n];\n\n// helpers //////////////////////\n\n/**\n * Calculates a reference point delta relative to a new position\n * of a certain element's bounds\n *\n * @param {Point} point\n * @param {Bounds} oldBounds\n * @param {Bounds} newBounds\n *\n * @return {Delta} delta\n */\nexport function getReferencePointDelta(referencePoint, oldBounds, newBounds) {\n\n  var newReferencePoint = getNewAttachPoint(referencePoint, oldBounds, newBounds);\n\n  return roundPoint(delta(newReferencePoint, referencePoint));\n}\n\n/**\n * Generates the nearest point (reference point) for a given point\n * onto given set of lines\n *\n * @param {Array<Point, Point>} lines\n * @param {Point} point\n *\n * @param {Point}\n */\nexport function getReferencePoint(point, lines) {\n\n  if (!lines.length) {\n    return;\n  }\n\n  var nearestLine = getNearestLine(point, lines);\n\n  return perpendicularFoot(point, nearestLine);\n}\n\n/**\n * Convert the given bounds to a lines array containing all edges\n *\n * @param {Bounds|Point} bounds\n *\n * @return Array<Point>\n */\nexport function asEdges(bounds) {\n  return [\n    [ // top\n      {\n        x: bounds.x,\n        y: bounds.y\n      },\n      {\n        x: bounds.x + (bounds.width || 0),\n        y: bounds.y\n      }\n    ],\n    [ // right\n      {\n        x: bounds.x + (bounds.width || 0),\n        y: bounds.y\n      },\n      {\n        x: bounds.x + (bounds.width || 0),\n        y: bounds.y + (bounds.height || 0)\n      }\n    ],\n    [ // bottom\n      {\n        x: bounds.x,\n        y: bounds.y + (bounds.height || 0)\n      },\n      {\n        x: bounds.x + (bounds.width || 0),\n        y: bounds.y + (bounds.height || 0)\n      }\n    ],\n    [ // left\n      {\n        x: bounds.x,\n        y: bounds.y\n      },\n      {\n        x: bounds.x,\n        y: bounds.y + (bounds.height || 0)\n      }\n    ]\n  ];\n}\n\n/**\n * Returns the nearest line for a given point by distance\n * @param {Point} point\n * @param Array<Point> lines\n *\n * @return Array<Point>\n */\nfunction getNearestLine(point, lines) {\n\n  var distances = lines.map(function(l) {\n    return {\n      line: l,\n      distance: getDistancePointLine(point, l)\n    };\n  });\n\n  var sorted = sortBy(distances, 'distance');\n\n  return sorted[0].line;\n}\n"]},"metadata":{},"sourceType":"module"}