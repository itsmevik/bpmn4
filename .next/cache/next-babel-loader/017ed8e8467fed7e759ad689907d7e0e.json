{"ast":null,"code":"import _Array$isArray from \"@babel/runtime-corejs2/core-js/array/is-array\";\nimport { every, find, forEach, some } from 'min-dash';\nimport inherits from 'inherits';\nimport { is, getBusinessObject } from '../../util/ModelUtil';\nimport { getParent, isAny } from '../modeling/util/ModelingUtil';\nimport { isLabel } from '../../util/LabelUtil';\nimport { isExpanded, isEventSubProcess, isInterrupting, hasErrorEventDefinition, hasEscalationEventDefinition, hasCompensateEventDefinition } from '../../util/DiUtil';\nimport RuleProvider from 'diagram-js/lib/features/rules/RuleProvider';\nimport { getBoundaryAttachment as isBoundaryAttachment } from '../snapping/BpmnSnappingUtil';\n/**\n * BPMN specific modeling rule\n */\n\nexport default function BpmnRules(eventBus) {\n  RuleProvider.call(this, eventBus);\n}\ninherits(BpmnRules, RuleProvider);\nBpmnRules.$inject = ['eventBus'];\n\nBpmnRules.prototype.init = function () {\n  this.addRule('connection.start', function (context) {\n    var source = context.source;\n    return canStartConnection(source);\n  });\n  this.addRule('connection.create', function (context) {\n    var source = context.source,\n        target = context.target,\n        hints = context.hints || {},\n        targetParent = hints.targetParent,\n        targetAttach = hints.targetAttach; // don't allow incoming connections on\n    // newly created boundary events\n    // to boundary events\n\n    if (targetAttach) {\n      return false;\n    } // temporarily set target parent for scoping\n    // checks to work\n\n\n    if (targetParent) {\n      target.parent = targetParent;\n    }\n\n    try {\n      return canConnect(source, target);\n    } finally {\n      // unset temporary target parent\n      if (targetParent) {\n        target.parent = null;\n      }\n    }\n  });\n  this.addRule('connection.reconnect', function (context) {\n    var connection = context.connection,\n        source = context.source,\n        target = context.target;\n    return canConnect(source, target, connection);\n  });\n  this.addRule('connection.updateWaypoints', function (context) {\n    return {\n      type: context.connection.type\n    };\n  });\n  this.addRule('shape.resize', function (context) {\n    var shape = context.shape,\n        newBounds = context.newBounds;\n    return canResize(shape, newBounds);\n  });\n  this.addRule('elements.create', function (context) {\n    var elements = context.elements,\n        position = context.position,\n        target = context.target;\n    return every(elements, function (element) {\n      if (isConnection(element)) {\n        return canConnect(element.source, element.target, element);\n      }\n\n      if (element.host) {\n        return canAttach(element, element.host, null, position);\n      }\n\n      return canCreate(element, target, null, position);\n    });\n  });\n  this.addRule('elements.move', function (context) {\n    var target = context.target,\n        shapes = context.shapes,\n        position = context.position;\n    return canAttach(shapes, target, null, position) || canReplace(shapes, target, position) || canMove(shapes, target, position) || canInsert(shapes, target, position);\n  });\n  this.addRule('shape.create', function (context) {\n    return canCreate(context.shape, context.target, context.source, context.position);\n  });\n  this.addRule('shape.attach', function (context) {\n    return canAttach(context.shape, context.target, null, context.position);\n  });\n  this.addRule('element.copy', function (context) {\n    var element = context.element,\n        elements = context.elements;\n    return canCopy(elements, element);\n  });\n};\n\nBpmnRules.prototype.canConnectMessageFlow = canConnectMessageFlow;\nBpmnRules.prototype.canConnectSequenceFlow = canConnectSequenceFlow;\nBpmnRules.prototype.canConnectDataAssociation = canConnectDataAssociation;\nBpmnRules.prototype.canConnectAssociation = canConnectAssociation;\nBpmnRules.prototype.canMove = canMove;\nBpmnRules.prototype.canAttach = canAttach;\nBpmnRules.prototype.canReplace = canReplace;\nBpmnRules.prototype.canDrop = canDrop;\nBpmnRules.prototype.canInsert = canInsert;\nBpmnRules.prototype.canCreate = canCreate;\nBpmnRules.prototype.canConnect = canConnect;\nBpmnRules.prototype.canResize = canResize;\nBpmnRules.prototype.canCopy = canCopy;\n/**\n * Utility functions for rule checking\n */\n\n/**\n * Checks if given element can be used for starting connection.\n *\n * @param  {Element} source\n * @return {Boolean}\n */\n\nfunction canStartConnection(element) {\n  if (nonExistingOrLabel(element)) {\n    return null;\n  }\n\n  return isAny(element, ['bpmn:FlowNode', 'bpmn:InteractionNode', 'bpmn:DataObjectReference', 'bpmn:DataStoreReference']);\n}\n\nfunction nonExistingOrLabel(element) {\n  return !element || isLabel(element);\n}\n\nfunction isSame(a, b) {\n  return a === b;\n}\n\nfunction getOrganizationalParent(element) {\n  do {\n    if (is(element, 'bpmn:Process')) {\n      return getBusinessObject(element);\n    }\n\n    if (is(element, 'bpmn:Participant')) {\n      return getBusinessObject(element).processRef || getBusinessObject(element);\n    }\n  } while (element = element.parent);\n}\n\nfunction isTextAnnotation(element) {\n  return is(element, 'bpmn:TextAnnotation');\n}\n\nfunction isGroup(element) {\n  return is(element, 'bpmn:Group') && !element.labelTarget;\n}\n\nfunction isCompensationBoundary(element) {\n  return is(element, 'bpmn:BoundaryEvent') && hasEventDefinition(element, 'bpmn:CompensateEventDefinition');\n}\n\nfunction isForCompensation(e) {\n  return getBusinessObject(e).isForCompensation;\n}\n\nfunction isSameOrganization(a, b) {\n  var parentA = getOrganizationalParent(a),\n      parentB = getOrganizationalParent(b);\n  return parentA === parentB;\n}\n\nfunction isMessageFlowSource(element) {\n  return is(element, 'bpmn:InteractionNode') && (!is(element, 'bpmn:Event') || is(element, 'bpmn:ThrowEvent') && hasEventDefinitionOrNone(element, 'bpmn:MessageEventDefinition'));\n}\n\nfunction isMessageFlowTarget(element) {\n  return is(element, 'bpmn:InteractionNode') && !isForCompensation(element) && (!is(element, 'bpmn:Event') || is(element, 'bpmn:CatchEvent') && hasEventDefinitionOrNone(element, 'bpmn:MessageEventDefinition'));\n}\n\nfunction getScopeParent(element) {\n  var parent = element;\n\n  while (parent = parent.parent) {\n    if (is(parent, 'bpmn:FlowElementsContainer')) {\n      return getBusinessObject(parent);\n    }\n\n    if (is(parent, 'bpmn:Participant')) {\n      return getBusinessObject(parent).processRef;\n    }\n  }\n\n  return null;\n}\n\nfunction isSameScope(a, b) {\n  var scopeParentA = getScopeParent(a),\n      scopeParentB = getScopeParent(b);\n  return scopeParentA === scopeParentB;\n}\n\nfunction hasEventDefinition(element, eventDefinition) {\n  var bo = getBusinessObject(element);\n  return !!find(bo.eventDefinitions || [], function (definition) {\n    return is(definition, eventDefinition);\n  });\n}\n\nfunction hasEventDefinitionOrNone(element, eventDefinition) {\n  var bo = getBusinessObject(element);\n  return (bo.eventDefinitions || []).every(function (definition) {\n    return is(definition, eventDefinition);\n  });\n}\n\nfunction isSequenceFlowSource(element) {\n  return is(element, 'bpmn:FlowNode') && !is(element, 'bpmn:EndEvent') && !isEventSubProcess(element) && !(is(element, 'bpmn:IntermediateThrowEvent') && hasEventDefinition(element, 'bpmn:LinkEventDefinition')) && !isCompensationBoundary(element) && !isForCompensation(element);\n}\n\nfunction isSequenceFlowTarget(element) {\n  return is(element, 'bpmn:FlowNode') && !is(element, 'bpmn:StartEvent') && !is(element, 'bpmn:BoundaryEvent') && !isEventSubProcess(element) && !(is(element, 'bpmn:IntermediateCatchEvent') && hasEventDefinition(element, 'bpmn:LinkEventDefinition')) && !isForCompensation(element);\n}\n\nfunction isEventBasedTarget(element) {\n  return is(element, 'bpmn:ReceiveTask') || is(element, 'bpmn:IntermediateCatchEvent') && (hasEventDefinition(element, 'bpmn:MessageEventDefinition') || hasEventDefinition(element, 'bpmn:TimerEventDefinition') || hasEventDefinition(element, 'bpmn:ConditionalEventDefinition') || hasEventDefinition(element, 'bpmn:SignalEventDefinition'));\n}\n\nfunction isConnection(element) {\n  return element.waypoints;\n}\n\nfunction getParents(element) {\n  var parents = [];\n\n  while (element) {\n    element = element.parent;\n\n    if (element) {\n      parents.push(element);\n    }\n  }\n\n  return parents;\n}\n\nfunction isParent(possibleParent, element) {\n  var allParents = getParents(element);\n  return allParents.indexOf(possibleParent) !== -1;\n}\n\nfunction canConnect(source, target, connection) {\n  if (nonExistingOrLabel(source) || nonExistingOrLabel(target)) {\n    return null;\n  }\n\n  if (!is(connection, 'bpmn:DataAssociation')) {\n    if (canConnectMessageFlow(source, target)) {\n      return {\n        type: 'bpmn:MessageFlow'\n      };\n    }\n\n    if (canConnectSequenceFlow(source, target)) {\n      return {\n        type: 'bpmn:SequenceFlow'\n      };\n    }\n  }\n\n  var connectDataAssociation = canConnectDataAssociation(source, target);\n\n  if (connectDataAssociation) {\n    return connectDataAssociation;\n  }\n\n  if (isCompensationBoundary(source) && isForCompensation(target)) {\n    return {\n      type: 'bpmn:Association',\n      associationDirection: 'One'\n    };\n  }\n\n  if (canConnectAssociation(source, target)) {\n    return {\n      type: 'bpmn:Association'\n    };\n  }\n\n  return false;\n}\n/**\n * Can an element be dropped into the target element\n *\n * @return {Boolean}\n */\n\n\nfunction canDrop(element, target, position) {\n  // can move labels and groups everywhere\n  if (isLabel(element) || isGroup(element)) {\n    return true;\n  } // disallow to create elements on collapsed pools\n\n\n  if (is(target, 'bpmn:Participant') && !isExpanded(target)) {\n    return false;\n  } // allow to create new participants on\n  // existing collaboration and process diagrams\n\n\n  if (is(element, 'bpmn:Participant')) {\n    return is(target, 'bpmn:Process') || is(target, 'bpmn:Collaboration');\n  } // allow moving DataInput / DataOutput within its original container only\n\n\n  if (isAny(element, ['bpmn:DataInput', 'bpmn:DataOutput'])) {\n    if (element.parent) {\n      return target === element.parent;\n    }\n  } // allow creating lanes on participants and other lanes only\n\n\n  if (is(element, 'bpmn:Lane')) {\n    return is(target, 'bpmn:Participant') || is(target, 'bpmn:Lane');\n  } // disallow dropping boundary events which cannot replace with intermediate event\n\n\n  if (is(element, 'bpmn:BoundaryEvent') && !isDroppableBoundaryEvent(element)) {\n    return false;\n  } // drop flow elements onto flow element containers\n  // and participants\n\n\n  if (is(element, 'bpmn:FlowElement') && !is(element, 'bpmn:DataStoreReference')) {\n    if (is(target, 'bpmn:FlowElementsContainer')) {\n      return isExpanded(target);\n    }\n\n    return isAny(target, ['bpmn:Participant', 'bpmn:Lane']);\n  } // account for the fact that data associations are always\n  // rendered and moved to top (Process or Collaboration level)\n  //\n  // artifacts may be placed wherever, too\n\n\n  if (isAny(element, ['bpmn:Artifact', 'bpmn:DataAssociation', 'bpmn:DataStoreReference'])) {\n    return isAny(target, ['bpmn:Collaboration', 'bpmn:Lane', 'bpmn:Participant', 'bpmn:Process', 'bpmn:SubProcess']);\n  }\n\n  if (is(element, 'bpmn:MessageFlow')) {\n    return is(target, 'bpmn:Collaboration') || element.source.parent == target || element.target.parent == target;\n  }\n\n  return false;\n}\n\nfunction isDroppableBoundaryEvent(event) {\n  return getBusinessObject(event).cancelActivity && (hasNoEventDefinition(event) || hasCommonBoundaryIntermediateEventDefinition(event));\n}\n\nfunction isBoundaryEvent(element) {\n  return !isLabel(element) && is(element, 'bpmn:BoundaryEvent');\n}\n\nfunction isLane(element) {\n  return is(element, 'bpmn:Lane');\n}\n/**\n * We treat IntermediateThrowEvents as boundary events during create,\n * this must be reflected in the rules.\n */\n\n\nfunction isBoundaryCandidate(element) {\n  if (isBoundaryEvent(element)) {\n    return true;\n  }\n\n  if (is(element, 'bpmn:IntermediateThrowEvent') && hasNoEventDefinition(element)) {\n    return true;\n  }\n\n  return is(element, 'bpmn:IntermediateCatchEvent') && hasCommonBoundaryIntermediateEventDefinition(element);\n}\n\nfunction hasNoEventDefinition(element) {\n  var bo = getBusinessObject(element);\n  return bo && !(bo.eventDefinitions && bo.eventDefinitions.length);\n}\n\nfunction hasCommonBoundaryIntermediateEventDefinition(element) {\n  return hasOneOfEventDefinitions(element, ['bpmn:MessageEventDefinition', 'bpmn:TimerEventDefinition', 'bpmn:SignalEventDefinition', 'bpmn:ConditionalEventDefinition']);\n}\n\nfunction hasOneOfEventDefinitions(element, eventDefinitions) {\n  return eventDefinitions.some(function (definition) {\n    return hasEventDefinition(element, definition);\n  });\n}\n\nfunction isReceiveTaskAfterEventBasedGateway(element) {\n  return is(element, 'bpmn:ReceiveTask') && find(element.incoming, function (incoming) {\n    return is(incoming.source, 'bpmn:EventBasedGateway');\n  });\n}\n\nfunction canAttach(elements, target, source, position) {\n  if (!_Array$isArray(elements)) {\n    elements = [elements];\n  } // only (re-)attach one element at a time\n\n\n  if (elements.length !== 1) {\n    return false;\n  }\n\n  var element = elements[0]; // do not attach labels\n\n  if (isLabel(element)) {\n    return false;\n  } // only handle boundary events\n\n\n  if (!isBoundaryCandidate(element)) {\n    return false;\n  } // disallow drop on event sub processes\n\n\n  if (isEventSubProcess(target)) {\n    return false;\n  } // only allow drop on non compensation activities\n\n\n  if (!is(target, 'bpmn:Activity') || isForCompensation(target)) {\n    return false;\n  } // only attach to subprocess border\n\n\n  if (position && !isBoundaryAttachment(position, target)) {\n    return false;\n  } // do not attach on receive tasks after event based gateways\n\n\n  if (isReceiveTaskAfterEventBasedGateway(target)) {\n    return false;\n  }\n\n  return 'attach';\n}\n/**\n * Defines how to replace elements for a given target.\n *\n * Returns an array containing all elements which will be replaced.\n *\n * @example\n *\n *  [{ id: 'IntermediateEvent_2',\n *     type: 'bpmn:StartEvent'\n *   },\n *   { id: 'IntermediateEvent_5',\n *     type: 'bpmn:EndEvent'\n *   }]\n *\n * @param  {Array} elements\n * @param  {Object} target\n *\n * @return {Object} an object containing all elements which have to be replaced\n */\n\n\nfunction canReplace(elements, target, position) {\n  if (!target) {\n    return false;\n  }\n\n  var canExecute = {\n    replacements: []\n  };\n  forEach(elements, function (element) {\n    if (!isEventSubProcess(target)) {\n      if (is(element, 'bpmn:StartEvent') && element.type !== 'label' && canDrop(element, target)) {\n        // replace a non-interrupting start event by a blank interrupting start event\n        // when the target is not an event sub process\n        if (!isInterrupting(element)) {\n          canExecute.replacements.push({\n            oldElementId: element.id,\n            newElementType: 'bpmn:StartEvent'\n          });\n        } // replace an error/escalation/compensate start event by a blank interrupting start event\n        // when the target is not an event sub process\n\n\n        if (hasErrorEventDefinition(element) || hasEscalationEventDefinition(element) || hasCompensateEventDefinition(element)) {\n          canExecute.replacements.push({\n            oldElementId: element.id,\n            newElementType: 'bpmn:StartEvent'\n          });\n        }\n      }\n    }\n\n    if (!is(target, 'bpmn:Transaction')) {\n      if (hasEventDefinition(element, 'bpmn:CancelEventDefinition') && element.type !== 'label') {\n        if (is(element, 'bpmn:EndEvent') && canDrop(element, target)) {\n          canExecute.replacements.push({\n            oldElementId: element.id,\n            newElementType: 'bpmn:EndEvent'\n          });\n        }\n\n        if (is(element, 'bpmn:BoundaryEvent') && canAttach(element, target, null, position)) {\n          canExecute.replacements.push({\n            oldElementId: element.id,\n            newElementType: 'bpmn:BoundaryEvent'\n          });\n        }\n      }\n    }\n  });\n  return canExecute.replacements.length ? canExecute : false;\n}\n\nfunction canMove(elements, target) {\n  // do not move selection containing lanes\n  if (some(elements, isLane)) {\n    return false;\n  } // allow default move check to start move operation\n\n\n  if (!target) {\n    return true;\n  }\n\n  return elements.every(function (element) {\n    return canDrop(element, target);\n  });\n}\n\nfunction canCreate(shape, target, source, position) {\n  if (!target) {\n    return false;\n  }\n\n  if (isLabel(shape) || isGroup(shape)) {\n    return true;\n  }\n\n  if (isSame(source, target)) {\n    return false;\n  } // ensure we do not drop the element\n  // into source\n\n\n  if (source && isParent(source, target)) {\n    return false;\n  }\n\n  return canDrop(shape, target, position) || canInsert(shape, target, position);\n}\n\nfunction canResize(shape, newBounds) {\n  if (is(shape, 'bpmn:SubProcess')) {\n    return isExpanded(shape) && (!newBounds || newBounds.width >= 100 && newBounds.height >= 80);\n  }\n\n  if (is(shape, 'bpmn:Lane')) {\n    return !newBounds || newBounds.width >= 130 && newBounds.height >= 60;\n  }\n\n  if (is(shape, 'bpmn:Participant')) {\n    return !newBounds || newBounds.width >= 250 && newBounds.height >= 50;\n  }\n\n  if (isTextAnnotation(shape)) {\n    return true;\n  }\n\n  if (isGroup(shape)) {\n    return true;\n  }\n\n  return false;\n}\n/**\n * Check, whether one side of the relationship\n * is a text annotation.\n */\n\n\nfunction isOneTextAnnotation(source, target) {\n  var sourceTextAnnotation = isTextAnnotation(source),\n      targetTextAnnotation = isTextAnnotation(target);\n  return (sourceTextAnnotation || targetTextAnnotation) && sourceTextAnnotation !== targetTextAnnotation;\n}\n\nfunction canConnectAssociation(source, target) {\n  // do not connect connections\n  if (isConnection(source) || isConnection(target)) {\n    return false;\n  } // compensation boundary events are exception\n\n\n  if (isCompensationBoundary(source) && isForCompensation(target)) {\n    return true;\n  } // don't connect parent <-> child\n\n\n  if (isParent(target, source) || isParent(source, target)) {\n    return false;\n  } // allow connection of associations between <!TextAnnotation> and <TextAnnotation>\n\n\n  if (isOneTextAnnotation(source, target)) {\n    return true;\n  } // can connect associations where we can connect\n  // data associations, too (!)\n\n\n  return !!canConnectDataAssociation(source, target);\n}\n\nfunction canConnectMessageFlow(source, target) {\n  // during connect user might move mouse out of canvas\n  // https://github.com/bpmn-io/bpmn-js/issues/1033\n  if (getRootElement(source) && !getRootElement(target)) {\n    return false;\n  }\n\n  return isMessageFlowSource(source) && isMessageFlowTarget(target) && !isSameOrganization(source, target);\n}\n\nfunction canConnectSequenceFlow(source, target) {\n  if (isEventBasedTarget(target) && target.incoming.length > 0 && areOutgoingEventBasedGatewayConnections(target.incoming) && !is(source, 'bpmn:EventBasedGateway')) {\n    return false;\n  }\n\n  return isSequenceFlowSource(source) && isSequenceFlowTarget(target) && isSameScope(source, target) && !(is(source, 'bpmn:EventBasedGateway') && !isEventBasedTarget(target));\n}\n\nfunction canConnectDataAssociation(source, target) {\n  if (isAny(source, ['bpmn:DataObjectReference', 'bpmn:DataStoreReference']) && isAny(target, ['bpmn:Activity', 'bpmn:ThrowEvent'])) {\n    return {\n      type: 'bpmn:DataInputAssociation'\n    };\n  }\n\n  if (isAny(target, ['bpmn:DataObjectReference', 'bpmn:DataStoreReference']) && isAny(source, ['bpmn:Activity', 'bpmn:CatchEvent'])) {\n    return {\n      type: 'bpmn:DataOutputAssociation'\n    };\n  }\n\n  return false;\n}\n\nfunction canInsert(shape, flow, position) {\n  if (!flow) {\n    return false;\n  }\n\n  if (_Array$isArray(shape)) {\n    if (shape.length !== 1) {\n      return false;\n    }\n\n    shape = shape[0];\n  }\n\n  if (flow.source === shape || flow.target === shape) {\n    return false;\n  } // return true if we can drop on the\n  // underlying flow parent\n  //\n  // at this point we are not really able to talk\n  // about connection rules (yet)\n\n\n  return isAny(flow, ['bpmn:SequenceFlow', 'bpmn:MessageFlow']) && !isLabel(flow) && is(shape, 'bpmn:FlowNode') && !is(shape, 'bpmn:BoundaryEvent') && canDrop(shape, flow.parent, position);\n}\n\nfunction includes(elements, element) {\n  return elements && element && elements.indexOf(element) !== -1;\n}\n\nfunction canCopy(elements, element) {\n  if (isLabel(element)) {\n    return true;\n  }\n\n  if (is(element, 'bpmn:Lane') && !includes(elements, element.parent)) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction isOutgoingEventBasedGatewayConnection(connection) {\n  if (connection && connection.source) {\n    return is(connection.source, 'bpmn:EventBasedGateway');\n  }\n}\n\nfunction areOutgoingEventBasedGatewayConnections(connections) {\n  connections = connections || [];\n  return connections.some(isOutgoingEventBasedGatewayConnection);\n}\n\nfunction getRootElement(element) {\n  return getParent(element, 'bpmn:Process') || getParent(element, 'bpmn:Collaboration');\n}","map":{"version":3,"sources":["/Users/believecreative/Kumar/bpmn/node_modules/bpmn-js/lib/features/rules/BpmnRules.js"],"names":["every","find","forEach","some","inherits","is","getBusinessObject","getParent","isAny","isLabel","isExpanded","isEventSubProcess","isInterrupting","hasErrorEventDefinition","hasEscalationEventDefinition","hasCompensateEventDefinition","RuleProvider","getBoundaryAttachment","isBoundaryAttachment","BpmnRules","eventBus","call","$inject","prototype","init","addRule","context","source","canStartConnection","target","hints","targetParent","targetAttach","parent","canConnect","connection","type","shape","newBounds","canResize","elements","position","element","isConnection","host","canAttach","canCreate","shapes","canReplace","canMove","canInsert","canCopy","canConnectMessageFlow","canConnectSequenceFlow","canConnectDataAssociation","canConnectAssociation","canDrop","nonExistingOrLabel","isSame","a","b","getOrganizationalParent","processRef","isTextAnnotation","isGroup","labelTarget","isCompensationBoundary","hasEventDefinition","isForCompensation","e","isSameOrganization","parentA","parentB","isMessageFlowSource","hasEventDefinitionOrNone","isMessageFlowTarget","getScopeParent","isSameScope","scopeParentA","scopeParentB","eventDefinition","bo","eventDefinitions","definition","isSequenceFlowSource","isSequenceFlowTarget","isEventBasedTarget","waypoints","getParents","parents","push","isParent","possibleParent","allParents","indexOf","connectDataAssociation","associationDirection","isDroppableBoundaryEvent","event","cancelActivity","hasNoEventDefinition","hasCommonBoundaryIntermediateEventDefinition","isBoundaryEvent","isLane","isBoundaryCandidate","length","hasOneOfEventDefinitions","isReceiveTaskAfterEventBasedGateway","incoming","canExecute","replacements","oldElementId","id","newElementType","width","height","isOneTextAnnotation","sourceTextAnnotation","targetTextAnnotation","getRootElement","areOutgoingEventBasedGatewayConnections","flow","includes","isOutgoingEventBasedGatewayConnection","connections"],"mappings":"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","sourcesContent":["import {\n  every,\n  find,\n  forEach,\n  some\n} from 'min-dash';\n\nimport inherits from 'inherits';\n\nimport {\n  is,\n  getBusinessObject\n} from '../../util/ModelUtil';\n\nimport {\n  getParent,\n  isAny\n} from '../modeling/util/ModelingUtil';\n\nimport {\n  isLabel\n} from '../../util/LabelUtil';\n\nimport {\n  isExpanded,\n  isEventSubProcess,\n  isInterrupting,\n  hasErrorEventDefinition,\n  hasEscalationEventDefinition,\n  hasCompensateEventDefinition\n} from '../../util/DiUtil';\n\nimport RuleProvider from 'diagram-js/lib/features/rules/RuleProvider';\n\nimport {\n  getBoundaryAttachment as isBoundaryAttachment\n} from '../snapping/BpmnSnappingUtil';\n\n\n/**\n * BPMN specific modeling rule\n */\nexport default function BpmnRules(eventBus) {\n  RuleProvider.call(this, eventBus);\n}\n\ninherits(BpmnRules, RuleProvider);\n\nBpmnRules.$inject = [ 'eventBus' ];\n\nBpmnRules.prototype.init = function() {\n\n  this.addRule('connection.start', function(context) {\n    var source = context.source;\n\n    return canStartConnection(source);\n  });\n\n  this.addRule('connection.create', function(context) {\n    var source = context.source,\n        target = context.target,\n        hints = context.hints || {},\n        targetParent = hints.targetParent,\n        targetAttach = hints.targetAttach;\n\n    // don't allow incoming connections on\n    // newly created boundary events\n    // to boundary events\n    if (targetAttach) {\n      return false;\n    }\n\n    // temporarily set target parent for scoping\n    // checks to work\n    if (targetParent) {\n      target.parent = targetParent;\n    }\n\n    try {\n      return canConnect(source, target);\n    } finally {\n\n      // unset temporary target parent\n      if (targetParent) {\n        target.parent = null;\n      }\n    }\n  });\n\n  this.addRule('connection.reconnect', function(context) {\n\n    var connection = context.connection,\n        source = context.source,\n        target = context.target;\n\n    return canConnect(source, target, connection);\n  });\n\n  this.addRule('connection.updateWaypoints', function(context) {\n    return {\n      type: context.connection.type\n    };\n  });\n\n  this.addRule('shape.resize', function(context) {\n\n    var shape = context.shape,\n        newBounds = context.newBounds;\n\n    return canResize(shape, newBounds);\n  });\n\n  this.addRule('elements.create', function(context) {\n    var elements = context.elements,\n        position = context.position,\n        target = context.target;\n\n    return every(elements, function(element) {\n      if (isConnection(element)) {\n        return canConnect(element.source, element.target, element);\n      }\n\n      if (element.host) {\n        return canAttach(element, element.host, null, position);\n      }\n\n      return canCreate(element, target, null, position);\n    });\n  });\n\n  this.addRule('elements.move', function(context) {\n\n    var target = context.target,\n        shapes = context.shapes,\n        position = context.position;\n\n    return canAttach(shapes, target, null, position) ||\n           canReplace(shapes, target, position) ||\n           canMove(shapes, target, position) ||\n           canInsert(shapes, target, position);\n  });\n\n  this.addRule('shape.create', function(context) {\n    return canCreate(\n      context.shape,\n      context.target,\n      context.source,\n      context.position\n    );\n  });\n\n  this.addRule('shape.attach', function(context) {\n\n    return canAttach(\n      context.shape,\n      context.target,\n      null,\n      context.position\n    );\n  });\n\n  this.addRule('element.copy', function(context) {\n    var element = context.element,\n        elements = context.elements;\n\n    return canCopy(elements, element);\n  });\n};\n\nBpmnRules.prototype.canConnectMessageFlow = canConnectMessageFlow;\n\nBpmnRules.prototype.canConnectSequenceFlow = canConnectSequenceFlow;\n\nBpmnRules.prototype.canConnectDataAssociation = canConnectDataAssociation;\n\nBpmnRules.prototype.canConnectAssociation = canConnectAssociation;\n\nBpmnRules.prototype.canMove = canMove;\n\nBpmnRules.prototype.canAttach = canAttach;\n\nBpmnRules.prototype.canReplace = canReplace;\n\nBpmnRules.prototype.canDrop = canDrop;\n\nBpmnRules.prototype.canInsert = canInsert;\n\nBpmnRules.prototype.canCreate = canCreate;\n\nBpmnRules.prototype.canConnect = canConnect;\n\nBpmnRules.prototype.canResize = canResize;\n\nBpmnRules.prototype.canCopy = canCopy;\n\n/**\n * Utility functions for rule checking\n */\n\n/**\n * Checks if given element can be used for starting connection.\n *\n * @param  {Element} source\n * @return {Boolean}\n */\nfunction canStartConnection(element) {\n  if (nonExistingOrLabel(element)) {\n    return null;\n  }\n\n  return isAny(element, [\n    'bpmn:FlowNode',\n    'bpmn:InteractionNode',\n    'bpmn:DataObjectReference',\n    'bpmn:DataStoreReference'\n  ]);\n}\n\nfunction nonExistingOrLabel(element) {\n  return !element || isLabel(element);\n}\n\nfunction isSame(a, b) {\n  return a === b;\n}\n\nfunction getOrganizationalParent(element) {\n\n  do {\n    if (is(element, 'bpmn:Process')) {\n      return getBusinessObject(element);\n    }\n\n    if (is(element, 'bpmn:Participant')) {\n      return (\n        getBusinessObject(element).processRef ||\n        getBusinessObject(element)\n      );\n    }\n  } while ((element = element.parent));\n\n}\n\nfunction isTextAnnotation(element) {\n  return is(element, 'bpmn:TextAnnotation');\n}\n\nfunction isGroup(element) {\n  return is(element, 'bpmn:Group') && !element.labelTarget;\n}\n\nfunction isCompensationBoundary(element) {\n  return is(element, 'bpmn:BoundaryEvent') &&\n         hasEventDefinition(element, 'bpmn:CompensateEventDefinition');\n}\n\nfunction isForCompensation(e) {\n  return getBusinessObject(e).isForCompensation;\n}\n\nfunction isSameOrganization(a, b) {\n  var parentA = getOrganizationalParent(a),\n      parentB = getOrganizationalParent(b);\n\n  return parentA === parentB;\n}\n\nfunction isMessageFlowSource(element) {\n  return (\n    is(element, 'bpmn:InteractionNode') && (\n      !is(element, 'bpmn:Event') || (\n        is(element, 'bpmn:ThrowEvent') &&\n        hasEventDefinitionOrNone(element, 'bpmn:MessageEventDefinition')\n      )\n    )\n  );\n}\n\nfunction isMessageFlowTarget(element) {\n  return (\n    is(element, 'bpmn:InteractionNode') &&\n    !isForCompensation(element) && (\n      !is(element, 'bpmn:Event') || (\n        is(element, 'bpmn:CatchEvent') &&\n        hasEventDefinitionOrNone(element, 'bpmn:MessageEventDefinition')\n      )\n    )\n  );\n}\n\nfunction getScopeParent(element) {\n\n  var parent = element;\n\n  while ((parent = parent.parent)) {\n\n    if (is(parent, 'bpmn:FlowElementsContainer')) {\n      return getBusinessObject(parent);\n    }\n\n    if (is(parent, 'bpmn:Participant')) {\n      return getBusinessObject(parent).processRef;\n    }\n  }\n\n  return null;\n}\n\nfunction isSameScope(a, b) {\n  var scopeParentA = getScopeParent(a),\n      scopeParentB = getScopeParent(b);\n\n  return scopeParentA === scopeParentB;\n}\n\nfunction hasEventDefinition(element, eventDefinition) {\n  var bo = getBusinessObject(element);\n\n  return !!find(bo.eventDefinitions || [], function(definition) {\n    return is(definition, eventDefinition);\n  });\n}\n\nfunction hasEventDefinitionOrNone(element, eventDefinition) {\n  var bo = getBusinessObject(element);\n\n  return (bo.eventDefinitions || []).every(function(definition) {\n    return is(definition, eventDefinition);\n  });\n}\n\nfunction isSequenceFlowSource(element) {\n  return (\n    is(element, 'bpmn:FlowNode') &&\n    !is(element, 'bpmn:EndEvent') &&\n    !isEventSubProcess(element) &&\n    !(is(element, 'bpmn:IntermediateThrowEvent') &&\n      hasEventDefinition(element, 'bpmn:LinkEventDefinition')\n    ) &&\n    !isCompensationBoundary(element) &&\n    !isForCompensation(element)\n  );\n}\n\nfunction isSequenceFlowTarget(element) {\n  return (\n    is(element, 'bpmn:FlowNode') &&\n    !is(element, 'bpmn:StartEvent') &&\n    !is(element, 'bpmn:BoundaryEvent') &&\n    !isEventSubProcess(element) &&\n    !(is(element, 'bpmn:IntermediateCatchEvent') &&\n      hasEventDefinition(element, 'bpmn:LinkEventDefinition')\n    ) &&\n    !isForCompensation(element)\n  );\n}\n\nfunction isEventBasedTarget(element) {\n  return (\n    is(element, 'bpmn:ReceiveTask') || (\n      is(element, 'bpmn:IntermediateCatchEvent') && (\n        hasEventDefinition(element, 'bpmn:MessageEventDefinition') ||\n        hasEventDefinition(element, 'bpmn:TimerEventDefinition') ||\n        hasEventDefinition(element, 'bpmn:ConditionalEventDefinition') ||\n        hasEventDefinition(element, 'bpmn:SignalEventDefinition')\n      )\n    )\n  );\n}\n\nfunction isConnection(element) {\n  return element.waypoints;\n}\n\nfunction getParents(element) {\n\n  var parents = [];\n\n  while (element) {\n    element = element.parent;\n\n    if (element) {\n      parents.push(element);\n    }\n  }\n\n  return parents;\n}\n\nfunction isParent(possibleParent, element) {\n  var allParents = getParents(element);\n  return allParents.indexOf(possibleParent) !== -1;\n}\n\nfunction canConnect(source, target, connection) {\n\n  if (nonExistingOrLabel(source) || nonExistingOrLabel(target)) {\n    return null;\n  }\n\n  if (!is(connection, 'bpmn:DataAssociation')) {\n\n    if (canConnectMessageFlow(source, target)) {\n      return { type: 'bpmn:MessageFlow' };\n    }\n\n    if (canConnectSequenceFlow(source, target)) {\n      return { type: 'bpmn:SequenceFlow' };\n    }\n  }\n\n  var connectDataAssociation = canConnectDataAssociation(source, target);\n\n  if (connectDataAssociation) {\n    return connectDataAssociation;\n  }\n\n  if (isCompensationBoundary(source) && isForCompensation(target)) {\n    return {\n      type: 'bpmn:Association',\n      associationDirection: 'One'\n    };\n  }\n\n  if (canConnectAssociation(source, target)) {\n\n    return {\n      type: 'bpmn:Association'\n    };\n  }\n\n  return false;\n}\n\n/**\n * Can an element be dropped into the target element\n *\n * @return {Boolean}\n */\nfunction canDrop(element, target, position) {\n\n  // can move labels and groups everywhere\n  if (isLabel(element) || isGroup(element)) {\n    return true;\n  }\n\n\n  // disallow to create elements on collapsed pools\n  if (is(target, 'bpmn:Participant') && !isExpanded(target)) {\n    return false;\n  }\n\n  // allow to create new participants on\n  // existing collaboration and process diagrams\n  if (is(element, 'bpmn:Participant')) {\n    return is(target, 'bpmn:Process') || is(target, 'bpmn:Collaboration');\n  }\n\n  // allow moving DataInput / DataOutput within its original container only\n  if (isAny(element, [ 'bpmn:DataInput', 'bpmn:DataOutput' ])) {\n\n    if (element.parent) {\n      return target === element.parent;\n    }\n  }\n\n  // allow creating lanes on participants and other lanes only\n  if (is(element, 'bpmn:Lane')) {\n    return is(target, 'bpmn:Participant') || is(target, 'bpmn:Lane');\n  }\n\n  // disallow dropping boundary events which cannot replace with intermediate event\n  if (is(element, 'bpmn:BoundaryEvent') && !isDroppableBoundaryEvent(element)) {\n    return false;\n  }\n\n  // drop flow elements onto flow element containers\n  // and participants\n  if (is(element, 'bpmn:FlowElement') && !is(element, 'bpmn:DataStoreReference')) {\n    if (is(target, 'bpmn:FlowElementsContainer')) {\n      return isExpanded(target);\n    }\n\n    return isAny(target, [ 'bpmn:Participant', 'bpmn:Lane' ]);\n  }\n\n  // account for the fact that data associations are always\n  // rendered and moved to top (Process or Collaboration level)\n  //\n  // artifacts may be placed wherever, too\n  if (isAny(element, [ 'bpmn:Artifact', 'bpmn:DataAssociation', 'bpmn:DataStoreReference' ])) {\n    return isAny(target, [\n      'bpmn:Collaboration',\n      'bpmn:Lane',\n      'bpmn:Participant',\n      'bpmn:Process',\n      'bpmn:SubProcess' ]);\n  }\n\n  if (is(element, 'bpmn:MessageFlow')) {\n    return is(target, 'bpmn:Collaboration')\n      || element.source.parent == target\n      || element.target.parent == target;\n  }\n\n  return false;\n}\n\nfunction isDroppableBoundaryEvent(event) {\n  return getBusinessObject(event).cancelActivity && (\n    hasNoEventDefinition(event) || hasCommonBoundaryIntermediateEventDefinition(event)\n  );\n}\n\nfunction isBoundaryEvent(element) {\n  return !isLabel(element) && is(element, 'bpmn:BoundaryEvent');\n}\n\nfunction isLane(element) {\n  return is(element, 'bpmn:Lane');\n}\n\n/**\n * We treat IntermediateThrowEvents as boundary events during create,\n * this must be reflected in the rules.\n */\nfunction isBoundaryCandidate(element) {\n  if (isBoundaryEvent(element)) {\n    return true;\n  }\n\n  if (is(element, 'bpmn:IntermediateThrowEvent') && hasNoEventDefinition(element)) {\n    return true;\n  }\n\n  return (\n    is(element, 'bpmn:IntermediateCatchEvent') &&\n    hasCommonBoundaryIntermediateEventDefinition(element)\n  );\n}\n\nfunction hasNoEventDefinition(element) {\n  var bo = getBusinessObject(element);\n\n  return bo && !(bo.eventDefinitions && bo.eventDefinitions.length);\n}\n\nfunction hasCommonBoundaryIntermediateEventDefinition(element) {\n  return hasOneOfEventDefinitions(element, [\n    'bpmn:MessageEventDefinition',\n    'bpmn:TimerEventDefinition',\n    'bpmn:SignalEventDefinition',\n    'bpmn:ConditionalEventDefinition'\n  ]);\n}\n\nfunction hasOneOfEventDefinitions(element, eventDefinitions) {\n  return eventDefinitions.some(function(definition) {\n    return hasEventDefinition(element, definition);\n  });\n}\n\nfunction isReceiveTaskAfterEventBasedGateway(element) {\n  return (\n    is(element, 'bpmn:ReceiveTask') &&\n    find(element.incoming, function(incoming) {\n      return is(incoming.source, 'bpmn:EventBasedGateway');\n    })\n  );\n}\n\n\nfunction canAttach(elements, target, source, position) {\n\n  if (!Array.isArray(elements)) {\n    elements = [ elements ];\n  }\n\n  // only (re-)attach one element at a time\n  if (elements.length !== 1) {\n    return false;\n  }\n\n  var element = elements[0];\n\n  // do not attach labels\n  if (isLabel(element)) {\n    return false;\n  }\n\n  // only handle boundary events\n  if (!isBoundaryCandidate(element)) {\n    return false;\n  }\n\n  // disallow drop on event sub processes\n  if (isEventSubProcess(target)) {\n    return false;\n  }\n\n  // only allow drop on non compensation activities\n  if (!is(target, 'bpmn:Activity') || isForCompensation(target)) {\n    return false;\n  }\n\n  // only attach to subprocess border\n  if (position && !isBoundaryAttachment(position, target)) {\n    return false;\n  }\n\n  // do not attach on receive tasks after event based gateways\n  if (isReceiveTaskAfterEventBasedGateway(target)) {\n    return false;\n  }\n\n  return 'attach';\n}\n\n\n/**\n * Defines how to replace elements for a given target.\n *\n * Returns an array containing all elements which will be replaced.\n *\n * @example\n *\n *  [{ id: 'IntermediateEvent_2',\n *     type: 'bpmn:StartEvent'\n *   },\n *   { id: 'IntermediateEvent_5',\n *     type: 'bpmn:EndEvent'\n *   }]\n *\n * @param  {Array} elements\n * @param  {Object} target\n *\n * @return {Object} an object containing all elements which have to be replaced\n */\nfunction canReplace(elements, target, position) {\n\n  if (!target) {\n    return false;\n  }\n\n  var canExecute = {\n    replacements: []\n  };\n\n  forEach(elements, function(element) {\n\n    if (!isEventSubProcess(target)) {\n\n      if (is(element, 'bpmn:StartEvent') &&\n          element.type !== 'label' &&\n          canDrop(element, target)) {\n\n        // replace a non-interrupting start event by a blank interrupting start event\n        // when the target is not an event sub process\n        if (!isInterrupting(element)) {\n          canExecute.replacements.push({\n            oldElementId: element.id,\n            newElementType: 'bpmn:StartEvent'\n          });\n        }\n\n        // replace an error/escalation/compensate start event by a blank interrupting start event\n        // when the target is not an event sub process\n        if (hasErrorEventDefinition(element) ||\n            hasEscalationEventDefinition(element) ||\n            hasCompensateEventDefinition(element)) {\n          canExecute.replacements.push({\n            oldElementId: element.id,\n            newElementType: 'bpmn:StartEvent'\n          });\n        }\n      }\n    }\n\n    if (!is(target, 'bpmn:Transaction')) {\n      if (hasEventDefinition(element, 'bpmn:CancelEventDefinition') &&\n          element.type !== 'label') {\n\n        if (is(element, 'bpmn:EndEvent') && canDrop(element, target)) {\n          canExecute.replacements.push({\n            oldElementId: element.id,\n            newElementType: 'bpmn:EndEvent'\n          });\n        }\n\n        if (is(element, 'bpmn:BoundaryEvent') && canAttach(element, target, null, position)) {\n          canExecute.replacements.push({\n            oldElementId: element.id,\n            newElementType: 'bpmn:BoundaryEvent'\n          });\n        }\n      }\n    }\n  });\n\n  return canExecute.replacements.length ? canExecute : false;\n}\n\nfunction canMove(elements, target) {\n\n  // do not move selection containing lanes\n  if (some(elements, isLane)) {\n    return false;\n  }\n\n  // allow default move check to start move operation\n  if (!target) {\n    return true;\n  }\n\n  return elements.every(function(element) {\n    return canDrop(element, target);\n  });\n}\n\nfunction canCreate(shape, target, source, position) {\n\n  if (!target) {\n    return false;\n  }\n\n  if (isLabel(shape) || isGroup(shape)) {\n    return true;\n  }\n\n  if (isSame(source, target)) {\n    return false;\n  }\n\n  // ensure we do not drop the element\n  // into source\n  if (source && isParent(source, target)) {\n    return false;\n  }\n\n  return canDrop(shape, target, position) || canInsert(shape, target, position);\n}\n\nfunction canResize(shape, newBounds) {\n  if (is(shape, 'bpmn:SubProcess')) {\n    return (\n      isExpanded(shape) && (\n        !newBounds || (newBounds.width >= 100 && newBounds.height >= 80)\n      )\n    );\n  }\n\n  if (is(shape, 'bpmn:Lane')) {\n    return !newBounds || (newBounds.width >= 130 && newBounds.height >= 60);\n  }\n\n  if (is(shape, 'bpmn:Participant')) {\n    return !newBounds || (newBounds.width >= 250 && newBounds.height >= 50);\n  }\n\n  if (isTextAnnotation(shape)) {\n    return true;\n  }\n\n  if (isGroup(shape)) {\n    return true;\n  }\n\n  return false;\n}\n\n/**\n * Check, whether one side of the relationship\n * is a text annotation.\n */\nfunction isOneTextAnnotation(source, target) {\n\n  var sourceTextAnnotation = isTextAnnotation(source),\n      targetTextAnnotation = isTextAnnotation(target);\n\n  return (\n    (sourceTextAnnotation || targetTextAnnotation) &&\n    (sourceTextAnnotation !== targetTextAnnotation)\n  );\n}\n\n\nfunction canConnectAssociation(source, target) {\n\n  // do not connect connections\n  if (isConnection(source) || isConnection(target)) {\n    return false;\n  }\n\n  // compensation boundary events are exception\n  if (isCompensationBoundary(source) && isForCompensation(target)) {\n    return true;\n  }\n\n  // don't connect parent <-> child\n  if (isParent(target, source) || isParent(source, target)) {\n    return false;\n  }\n\n  // allow connection of associations between <!TextAnnotation> and <TextAnnotation>\n  if (isOneTextAnnotation(source, target)) {\n    return true;\n  }\n\n  // can connect associations where we can connect\n  // data associations, too (!)\n  return !!canConnectDataAssociation(source, target);\n}\n\nfunction canConnectMessageFlow(source, target) {\n\n  // during connect user might move mouse out of canvas\n  // https://github.com/bpmn-io/bpmn-js/issues/1033\n  if (getRootElement(source) && !getRootElement(target)) {\n    return false;\n  }\n\n  return (\n    isMessageFlowSource(source) &&\n    isMessageFlowTarget(target) &&\n    !isSameOrganization(source, target)\n  );\n}\n\nfunction canConnectSequenceFlow(source, target) {\n\n  if (\n    isEventBasedTarget(target) &&\n    target.incoming.length > 0 &&\n    areOutgoingEventBasedGatewayConnections(target.incoming) &&\n    !is(source, 'bpmn:EventBasedGateway')\n  ) {\n    return false;\n  }\n\n  return isSequenceFlowSource(source) &&\n         isSequenceFlowTarget(target) &&\n         isSameScope(source, target) &&\n         !(is(source, 'bpmn:EventBasedGateway') && !isEventBasedTarget(target));\n}\n\n\nfunction canConnectDataAssociation(source, target) {\n\n  if (isAny(source, [ 'bpmn:DataObjectReference', 'bpmn:DataStoreReference' ]) &&\n      isAny(target, [ 'bpmn:Activity', 'bpmn:ThrowEvent' ])) {\n    return { type: 'bpmn:DataInputAssociation' };\n  }\n\n  if (isAny(target, [ 'bpmn:DataObjectReference', 'bpmn:DataStoreReference' ]) &&\n      isAny(source, [ 'bpmn:Activity', 'bpmn:CatchEvent' ])) {\n    return { type: 'bpmn:DataOutputAssociation' };\n  }\n\n  return false;\n}\n\nfunction canInsert(shape, flow, position) {\n\n  if (!flow) {\n    return false;\n  }\n\n  if (Array.isArray(shape)) {\n    if (shape.length !== 1) {\n      return false;\n    }\n\n    shape = shape[0];\n  }\n\n  if (flow.source === shape ||\n      flow.target === shape) {\n    return false;\n  }\n\n  // return true if we can drop on the\n  // underlying flow parent\n  //\n  // at this point we are not really able to talk\n  // about connection rules (yet)\n\n  return (\n    isAny(flow, [ 'bpmn:SequenceFlow', 'bpmn:MessageFlow' ]) &&\n    !isLabel(flow) &&\n    is(shape, 'bpmn:FlowNode') &&\n    !is(shape, 'bpmn:BoundaryEvent') &&\n    canDrop(shape, flow.parent, position));\n}\n\nfunction includes(elements, element) {\n  return (elements && element) && elements.indexOf(element) !== -1;\n}\n\nfunction canCopy(elements, element) {\n  if (isLabel(element)) {\n    return true;\n  }\n\n  if (is(element, 'bpmn:Lane') && !includes(elements, element.parent)) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction isOutgoingEventBasedGatewayConnection(connection) {\n\n  if (connection && connection.source) {\n    return is(connection.source, 'bpmn:EventBasedGateway');\n  }\n}\n\nfunction areOutgoingEventBasedGatewayConnections(connections) {\n  connections = connections || [];\n\n  return connections.some(isOutgoingEventBasedGatewayConnection);\n}\n\nfunction getRootElement(element) {\n  return getParent(element, 'bpmn:Process') || getParent(element, 'bpmn:Collaboration');\n}\n"]},"metadata":{},"sourceType":"module"}