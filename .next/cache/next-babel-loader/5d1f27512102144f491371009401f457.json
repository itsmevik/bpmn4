{"ast":null,"code":"import { forEach, find, matchPattern } from 'min-dash';\nimport inherits from 'inherits';\nimport CommandInterceptor from 'diagram-js/lib/command/CommandInterceptor';\nimport { is } from '../../../util/ModelUtil';\nexport default function ReplaceConnectionBehavior(eventBus, modeling, bpmnRules, injector) {\n  CommandInterceptor.call(this, eventBus);\n  var dragging = injector.get('dragging', false);\n\n  function fixConnection(connection) {\n    var source = connection.source,\n        target = connection.target,\n        parent = connection.parent; // do not do anything if connection\n    // is already deleted (may happen due to other\n    // behaviors plugged-in before)\n\n    if (!parent) {\n      return;\n    }\n\n    var replacementType, remove;\n    /**\n     * Check if incoming or outgoing connections\n     * can stay or could be substituted with an\n     * appropriate replacement.\n     *\n     * This holds true for SequenceFlow <> MessageFlow.\n     */\n\n    if (is(connection, 'bpmn:SequenceFlow')) {\n      if (!bpmnRules.canConnectSequenceFlow(source, target)) {\n        remove = true;\n      }\n\n      if (bpmnRules.canConnectMessageFlow(source, target)) {\n        replacementType = 'bpmn:MessageFlow';\n      }\n    } // transform message flows into sequence flows, if possible\n\n\n    if (is(connection, 'bpmn:MessageFlow')) {\n      if (!bpmnRules.canConnectMessageFlow(source, target)) {\n        remove = true;\n      }\n\n      if (bpmnRules.canConnectSequenceFlow(source, target)) {\n        replacementType = 'bpmn:SequenceFlow';\n      }\n    }\n\n    if (is(connection, 'bpmn:Association') && !bpmnRules.canConnectAssociation(source, target)) {\n      remove = true;\n    } // remove invalid connection,\n    // unless it has been removed already\n\n\n    if (remove) {\n      modeling.removeConnection(connection);\n    } // replace SequenceFlow <> MessageFlow\n\n\n    if (replacementType) {\n      modeling.connect(source, target, {\n        type: replacementType,\n        waypoints: connection.waypoints.slice()\n      });\n    }\n  }\n\n  function replaceReconnectedConnection(event) {\n    var context = event.context,\n        connection = context.connection,\n        source = context.newSource || connection.source,\n        target = context.newTarget || connection.target,\n        allowed,\n        replacement;\n    allowed = bpmnRules.canConnect(source, target);\n\n    if (!allowed || allowed.type === connection.type) {\n      return;\n    }\n\n    replacement = modeling.connect(source, target, {\n      type: allowed.type,\n      waypoints: connection.waypoints.slice()\n    }); // remove old connection\n\n    modeling.removeConnection(connection); // replace connection in context to reconnect end/start\n\n    context.connection = replacement;\n\n    if (dragging) {\n      cleanDraggingSelection(connection, replacement);\n    }\n  } // monkey-patch selection saved in dragging in order to re-select it when operation is finished\n\n\n  function cleanDraggingSelection(oldConnection, newConnection) {\n    var context = dragging.context(),\n        previousSelection = context && context.payload.previousSelection,\n        index; // do nothing if not dragging or no selection was present\n\n    if (!previousSelection || !previousSelection.length) {\n      return;\n    }\n\n    index = previousSelection.indexOf(oldConnection);\n\n    if (index === -1) {\n      return;\n    }\n\n    previousSelection.splice(index, 1, newConnection);\n  } // lifecycle hooks\n\n\n  this.postExecuted('elements.move', function (context) {\n    var closure = context.closure,\n        allConnections = closure.allConnections;\n    forEach(allConnections, fixConnection);\n  }, true);\n  this.preExecute('connection.reconnect', replaceReconnectedConnection);\n  this.postExecuted('element.updateProperties', function (event) {\n    var context = event.context,\n        properties = context.properties,\n        element = context.element,\n        businessObject = element.businessObject,\n        connection; // remove condition on change to default\n\n    if (properties[\"default\"]) {\n      connection = find(element.outgoing, matchPattern({\n        id: element.businessObject[\"default\"].id\n      }));\n\n      if (connection) {\n        modeling.updateProperties(connection, {\n          conditionExpression: undefined\n        });\n      }\n    } // remove default from source on change to conditional\n\n\n    if (properties.conditionExpression && businessObject.sourceRef[\"default\"] === businessObject) {\n      modeling.updateProperties(element.source, {\n        \"default\": undefined\n      });\n    }\n  });\n}\ninherits(ReplaceConnectionBehavior, CommandInterceptor);\nReplaceConnectionBehavior.$inject = ['eventBus', 'modeling', 'bpmnRules', 'injector'];","map":{"version":3,"sources":["/Users/believecreative/Kumar/bpmn/node_modules/bpmn-js/lib/features/modeling/behavior/ReplaceConnectionBehavior.js"],"names":["forEach","find","matchPattern","inherits","CommandInterceptor","is","ReplaceConnectionBehavior","eventBus","modeling","bpmnRules","injector","call","dragging","get","fixConnection","connection","source","target","parent","replacementType","remove","canConnectSequenceFlow","canConnectMessageFlow","canConnectAssociation","removeConnection","connect","type","waypoints","slice","replaceReconnectedConnection","event","context","newSource","newTarget","allowed","replacement","canConnect","cleanDraggingSelection","oldConnection","newConnection","previousSelection","payload","index","length","indexOf","splice","postExecuted","closure","allConnections","preExecute","properties","element","businessObject","outgoing","id","updateProperties","conditionExpression","undefined","sourceRef","$inject"],"mappings":"AAAA,SACEA,OADF,EAEEC,IAFF,EAGEC,YAHF,QAIO,UAJP;AAMA,OAAOC,QAAP,MAAqB,UAArB;AAEA,OAAOC,kBAAP,MAA+B,2CAA/B;AAEA,SAASC,EAAT,QAAmB,yBAAnB;AAGA,eAAe,SAASC,yBAAT,CAAmCC,QAAnC,EAA6CC,QAA7C,EAAuDC,SAAvD,EAAkEC,QAAlE,EAA4E;AAEzFN,EAAAA,kBAAkB,CAACO,IAAnB,CAAwB,IAAxB,EAA8BJ,QAA9B;AAEA,MAAIK,QAAQ,GAAGF,QAAQ,CAACG,GAAT,CAAa,UAAb,EAAyB,KAAzB,CAAf;;AAEA,WAASC,aAAT,CAAuBC,UAAvB,EAAmC;AAEjC,QAAIC,MAAM,GAAGD,UAAU,CAACC,MAAxB;AAAA,QACIC,MAAM,GAAGF,UAAU,CAACE,MADxB;AAAA,QAEIC,MAAM,GAAGH,UAAU,CAACG,MAFxB,CAFiC,CAMjC;AACA;AACA;;AACA,QAAI,CAACA,MAAL,EAAa;AACX;AACD;;AAED,QAAIC,eAAJ,EACIC,MADJ;AAGA;;;;;;;;AAQA,QAAIf,EAAE,CAACU,UAAD,EAAa,mBAAb,CAAN,EAAyC;AACvC,UAAI,CAACN,SAAS,CAACY,sBAAV,CAAiCL,MAAjC,EAAyCC,MAAzC,CAAL,EAAuD;AACrDG,QAAAA,MAAM,GAAG,IAAT;AACD;;AAED,UAAIX,SAAS,CAACa,qBAAV,CAAgCN,MAAhC,EAAwCC,MAAxC,CAAJ,EAAqD;AACnDE,QAAAA,eAAe,GAAG,kBAAlB;AACD;AACF,KAhCgC,CAkCjC;;;AAEA,QAAId,EAAE,CAACU,UAAD,EAAa,kBAAb,CAAN,EAAwC;AAEtC,UAAI,CAACN,SAAS,CAACa,qBAAV,CAAgCN,MAAhC,EAAwCC,MAAxC,CAAL,EAAsD;AACpDG,QAAAA,MAAM,GAAG,IAAT;AACD;;AAED,UAAIX,SAAS,CAACY,sBAAV,CAAiCL,MAAjC,EAAyCC,MAAzC,CAAJ,EAAsD;AACpDE,QAAAA,eAAe,GAAG,mBAAlB;AACD;AACF;;AAED,QAAId,EAAE,CAACU,UAAD,EAAa,kBAAb,CAAF,IAAsC,CAACN,SAAS,CAACc,qBAAV,CAAgCP,MAAhC,EAAwCC,MAAxC,CAA3C,EAA4F;AAC1FG,MAAAA,MAAM,GAAG,IAAT;AACD,KAjDgC,CAoDjC;AACA;;;AACA,QAAIA,MAAJ,EAAY;AACVZ,MAAAA,QAAQ,CAACgB,gBAAT,CAA0BT,UAA1B;AACD,KAxDgC,CA0DjC;;;AAEA,QAAII,eAAJ,EAAqB;AACnBX,MAAAA,QAAQ,CAACiB,OAAT,CAAiBT,MAAjB,EAAyBC,MAAzB,EAAiC;AAC/BS,QAAAA,IAAI,EAAEP,eADyB;AAE/BQ,QAAAA,SAAS,EAAEZ,UAAU,CAACY,SAAX,CAAqBC,KAArB;AAFoB,OAAjC;AAID;AACF;;AAED,WAASC,4BAAT,CAAsCC,KAAtC,EAA6C;AAE3C,QAAIC,OAAO,GAAGD,KAAK,CAACC,OAApB;AAAA,QACIhB,UAAU,GAAGgB,OAAO,CAAChB,UADzB;AAAA,QAEIC,MAAM,GAAGe,OAAO,CAACC,SAAR,IAAqBjB,UAAU,CAACC,MAF7C;AAAA,QAGIC,MAAM,GAAGc,OAAO,CAACE,SAAR,IAAqBlB,UAAU,CAACE,MAH7C;AAAA,QAIIiB,OAJJ;AAAA,QAKIC,WALJ;AAOAD,IAAAA,OAAO,GAAGzB,SAAS,CAAC2B,UAAV,CAAqBpB,MAArB,EAA6BC,MAA7B,CAAV;;AAEA,QAAI,CAACiB,OAAD,IAAYA,OAAO,CAACR,IAAR,KAAiBX,UAAU,CAACW,IAA5C,EAAkD;AAChD;AACD;;AAEDS,IAAAA,WAAW,GAAG3B,QAAQ,CAACiB,OAAT,CAAiBT,MAAjB,EAAyBC,MAAzB,EAAiC;AAC7CS,MAAAA,IAAI,EAAEQ,OAAO,CAACR,IAD+B;AAE7CC,MAAAA,SAAS,EAAEZ,UAAU,CAACY,SAAX,CAAqBC,KAArB;AAFkC,KAAjC,CAAd,CAf2C,CAoB3C;;AACApB,IAAAA,QAAQ,CAACgB,gBAAT,CAA0BT,UAA1B,EArB2C,CAuB3C;;AACAgB,IAAAA,OAAO,CAAChB,UAAR,GAAqBoB,WAArB;;AAEA,QAAIvB,QAAJ,EAAc;AACZyB,MAAAA,sBAAsB,CAACtB,UAAD,EAAaoB,WAAb,CAAtB;AACD;AACF,GAvGwF,CAyGzF;;;AACA,WAASE,sBAAT,CAAgCC,aAAhC,EAA+CC,aAA/C,EAA8D;AAC5D,QAAIR,OAAO,GAAGnB,QAAQ,CAACmB,OAAT,EAAd;AAAA,QACIS,iBAAiB,GAAGT,OAAO,IAAIA,OAAO,CAACU,OAAR,CAAgBD,iBADnD;AAAA,QAEIE,KAFJ,CAD4D,CAK5D;;AACA,QAAI,CAACF,iBAAD,IAAsB,CAACA,iBAAiB,CAACG,MAA7C,EAAqD;AACnD;AACD;;AAEDD,IAAAA,KAAK,GAAGF,iBAAiB,CAACI,OAAlB,CAA0BN,aAA1B,CAAR;;AAEA,QAAII,KAAK,KAAK,CAAC,CAAf,EAAkB;AAChB;AACD;;AAEDF,IAAAA,iBAAiB,CAACK,MAAlB,CAAyBH,KAAzB,EAAgC,CAAhC,EAAmCH,aAAnC;AACD,GA3HwF,CA6HzF;;;AAEA,OAAKO,YAAL,CAAkB,eAAlB,EAAmC,UAASf,OAAT,EAAkB;AAEnD,QAAIgB,OAAO,GAAGhB,OAAO,CAACgB,OAAtB;AAAA,QACIC,cAAc,GAAGD,OAAO,CAACC,cAD7B;AAGAhD,IAAAA,OAAO,CAACgD,cAAD,EAAiBlC,aAAjB,CAAP;AACD,GAND,EAMG,IANH;AAQA,OAAKmC,UAAL,CAAgB,sBAAhB,EAAwCpB,4BAAxC;AAEA,OAAKiB,YAAL,CAAkB,0BAAlB,EAA8C,UAAShB,KAAT,EAAgB;AAC5D,QAAIC,OAAO,GAAGD,KAAK,CAACC,OAApB;AAAA,QACImB,UAAU,GAAGnB,OAAO,CAACmB,UADzB;AAAA,QAEIC,OAAO,GAAGpB,OAAO,CAACoB,OAFtB;AAAA,QAGIC,cAAc,GAAGD,OAAO,CAACC,cAH7B;AAAA,QAIIrC,UAJJ,CAD4D,CAO5D;;AACA,QAAImC,UAAU,WAAd,EAAwB;AACtBnC,MAAAA,UAAU,GAAGd,IAAI,CACfkD,OAAO,CAACE,QADO,EAEfnD,YAAY,CAAC;AAAEoD,QAAAA,EAAE,EAAEH,OAAO,CAACC,cAAR,YAA+BE;AAArC,OAAD,CAFG,CAAjB;;AAKA,UAAIvC,UAAJ,EAAgB;AACdP,QAAAA,QAAQ,CAAC+C,gBAAT,CAA0BxC,UAA1B,EAAsC;AAAEyC,UAAAA,mBAAmB,EAAEC;AAAvB,SAAtC;AACD;AACF,KAjB2D,CAmB5D;;;AACA,QAAIP,UAAU,CAACM,mBAAX,IAAkCJ,cAAc,CAACM,SAAf,gBAAqCN,cAA3E,EAA2F;AACzF5C,MAAAA,QAAQ,CAAC+C,gBAAT,CAA0BJ,OAAO,CAACnC,MAAlC,EAA0C;AAAE,mBAASyC;AAAX,OAA1C;AACD;AACF,GAvBD;AAwBD;AAEDtD,QAAQ,CAACG,yBAAD,EAA4BF,kBAA5B,CAAR;AAEAE,yBAAyB,CAACqD,OAA1B,GAAoC,CAClC,UADkC,EAElC,UAFkC,EAGlC,WAHkC,EAIlC,UAJkC,CAApC","sourcesContent":["import {\n  forEach,\n  find,\n  matchPattern\n} from 'min-dash';\n\nimport inherits from 'inherits';\n\nimport CommandInterceptor from 'diagram-js/lib/command/CommandInterceptor';\n\nimport { is } from '../../../util/ModelUtil';\n\n\nexport default function ReplaceConnectionBehavior(eventBus, modeling, bpmnRules, injector) {\n\n  CommandInterceptor.call(this, eventBus);\n\n  var dragging = injector.get('dragging', false);\n\n  function fixConnection(connection) {\n\n    var source = connection.source,\n        target = connection.target,\n        parent = connection.parent;\n\n    // do not do anything if connection\n    // is already deleted (may happen due to other\n    // behaviors plugged-in before)\n    if (!parent) {\n      return;\n    }\n\n    var replacementType,\n        remove;\n\n    /**\n     * Check if incoming or outgoing connections\n     * can stay or could be substituted with an\n     * appropriate replacement.\n     *\n     * This holds true for SequenceFlow <> MessageFlow.\n     */\n\n    if (is(connection, 'bpmn:SequenceFlow')) {\n      if (!bpmnRules.canConnectSequenceFlow(source, target)) {\n        remove = true;\n      }\n\n      if (bpmnRules.canConnectMessageFlow(source, target)) {\n        replacementType = 'bpmn:MessageFlow';\n      }\n    }\n\n    // transform message flows into sequence flows, if possible\n\n    if (is(connection, 'bpmn:MessageFlow')) {\n\n      if (!bpmnRules.canConnectMessageFlow(source, target)) {\n        remove = true;\n      }\n\n      if (bpmnRules.canConnectSequenceFlow(source, target)) {\n        replacementType = 'bpmn:SequenceFlow';\n      }\n    }\n\n    if (is(connection, 'bpmn:Association') && !bpmnRules.canConnectAssociation(source, target)) {\n      remove = true;\n    }\n\n\n    // remove invalid connection,\n    // unless it has been removed already\n    if (remove) {\n      modeling.removeConnection(connection);\n    }\n\n    // replace SequenceFlow <> MessageFlow\n\n    if (replacementType) {\n      modeling.connect(source, target, {\n        type: replacementType,\n        waypoints: connection.waypoints.slice()\n      });\n    }\n  }\n\n  function replaceReconnectedConnection(event) {\n\n    var context = event.context,\n        connection = context.connection,\n        source = context.newSource || connection.source,\n        target = context.newTarget || connection.target,\n        allowed,\n        replacement;\n\n    allowed = bpmnRules.canConnect(source, target);\n\n    if (!allowed || allowed.type === connection.type) {\n      return;\n    }\n\n    replacement = modeling.connect(source, target, {\n      type: allowed.type,\n      waypoints: connection.waypoints.slice()\n    });\n\n    // remove old connection\n    modeling.removeConnection(connection);\n\n    // replace connection in context to reconnect end/start\n    context.connection = replacement;\n\n    if (dragging) {\n      cleanDraggingSelection(connection, replacement);\n    }\n  }\n\n  // monkey-patch selection saved in dragging in order to re-select it when operation is finished\n  function cleanDraggingSelection(oldConnection, newConnection) {\n    var context = dragging.context(),\n        previousSelection = context && context.payload.previousSelection,\n        index;\n\n    // do nothing if not dragging or no selection was present\n    if (!previousSelection || !previousSelection.length) {\n      return;\n    }\n\n    index = previousSelection.indexOf(oldConnection);\n\n    if (index === -1) {\n      return;\n    }\n\n    previousSelection.splice(index, 1, newConnection);\n  }\n\n  // lifecycle hooks\n\n  this.postExecuted('elements.move', function(context) {\n\n    var closure = context.closure,\n        allConnections = closure.allConnections;\n\n    forEach(allConnections, fixConnection);\n  }, true);\n\n  this.preExecute('connection.reconnect', replaceReconnectedConnection);\n\n  this.postExecuted('element.updateProperties', function(event) {\n    var context = event.context,\n        properties = context.properties,\n        element = context.element,\n        businessObject = element.businessObject,\n        connection;\n\n    // remove condition on change to default\n    if (properties.default) {\n      connection = find(\n        element.outgoing,\n        matchPattern({ id: element.businessObject.default.id })\n      );\n\n      if (connection) {\n        modeling.updateProperties(connection, { conditionExpression: undefined });\n      }\n    }\n\n    // remove default from source on change to conditional\n    if (properties.conditionExpression && businessObject.sourceRef.default === businessObject) {\n      modeling.updateProperties(element.source, { default: undefined });\n    }\n  });\n}\n\ninherits(ReplaceConnectionBehavior, CommandInterceptor);\n\nReplaceConnectionBehavior.$inject = [\n  'eventBus',\n  'modeling',\n  'bpmnRules',\n  'injector'\n];\n"]},"metadata":{},"sourceType":"module"}