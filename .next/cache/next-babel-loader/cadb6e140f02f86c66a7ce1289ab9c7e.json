{"ast":null,"code":"import { is } from '../../util/ModelUtil';\nimport { isAny } from '../modeling/util/ModelingUtil';\nimport { getMid, asTRBL, getOrientation } from 'diagram-js/lib/layout/LayoutUtil';\nimport { find, reduce } from 'min-dash';\nvar DEFAULT_HORIZONTAL_DISTANCE = 50;\nvar MAX_HORIZONTAL_DISTANCE = 250; // padding to detect element placement\n\nvar PLACEMENT_DETECTION_PAD = 10;\n/**\n * Find the new position for the target element to\n * connect to source.\n *\n * @param  {djs.model.Shape} source\n * @param  {djs.model.Shape} element\n *\n * @return {Point}\n */\n\nexport function getNewShapePosition(source, element) {\n  if (is(element, 'bpmn:TextAnnotation')) {\n    return getTextAnnotationPosition(source, element);\n  }\n\n  if (isAny(element, ['bpmn:DataObjectReference', 'bpmn:DataStoreReference'])) {\n    return getDataElementPosition(source, element);\n  }\n\n  if (is(element, 'bpmn:FlowNode')) {\n    return getFlowNodePosition(source, element);\n  }\n\n  return getDefaultPosition(source, element);\n}\n/**\n * Always try to place element right of source;\n * compute actual distance from previous nodes in flow.\n */\n\nexport function getFlowNodePosition(source, element) {\n  var sourceTrbl = asTRBL(source);\n  var sourceMid = getMid(source);\n  var horizontalDistance = getFlowNodeDistance(source, element);\n  var orientation = 'left',\n      rowSize = 80,\n      margin = 30;\n\n  if (is(source, 'bpmn:BoundaryEvent')) {\n    orientation = getOrientation(source, source.host, -25);\n\n    if (orientation.indexOf('top') !== -1) {\n      margin *= -1;\n    }\n  }\n\n  function getVerticalDistance(orient) {\n    if (orient.indexOf('top') != -1) {\n      return -1 * rowSize;\n    } else if (orient.indexOf('bottom') != -1) {\n      return rowSize;\n    } else {\n      return 0;\n    }\n  }\n\n  var position = {\n    x: sourceTrbl.right + horizontalDistance + element.width / 2,\n    y: sourceMid.y + getVerticalDistance(orientation)\n  };\n  var escapeDirection = {\n    y: {\n      margin: margin,\n      rowSize: rowSize\n    }\n  };\n  return deconflictPosition(source, element, position, escapeDirection);\n}\n/**\n * Compute best distance between source and target,\n * based on existing connections to and from source.\n *\n * @param {djs.model.Shape} source\n * @param {djs.model.Shape} element\n *\n * @return {Number} distance\n */\n\nexport function getFlowNodeDistance(source, element) {\n  var sourceTrbl = asTRBL(source); // is connection a reference to consider?\n\n  function isReference(c) {\n    return is(c, 'bpmn:SequenceFlow');\n  }\n\n  function toTargetNode(weight) {\n    return function (shape) {\n      return {\n        shape: shape,\n        weight: weight,\n        distanceTo: function distanceTo(shape) {\n          var shapeTrbl = asTRBL(shape);\n          return shapeTrbl.left - sourceTrbl.right;\n        }\n      };\n    };\n  }\n\n  function toSourceNode(weight) {\n    return function (shape) {\n      return {\n        shape: shape,\n        weight: weight,\n        distanceTo: function distanceTo(shape) {\n          var shapeTrbl = asTRBL(shape);\n          return sourceTrbl.left - shapeTrbl.right;\n        }\n      };\n    };\n  } // we create a list of nodes to take into consideration\n  // for calculating the optimal flow node distance\n  //\n  //   * weight existing target nodes higher than source nodes\n  //   * only take into account individual nodes once\n  //\n\n\n  var nodes = reduce([].concat(getTargets(source, isReference).map(toTargetNode(5)), getSources(source, isReference).map(toSourceNode(1))), function (nodes, node) {\n    // filter out shapes connected twice via source or target\n    nodes[node.shape.id + '__weight_' + node.weight] = node;\n    return nodes;\n  }, {}); // compute distances between source and incoming nodes;\n  // group at the same time by distance and expose the\n  // favourite distance as { fav: { count, value } }.\n\n  var distancesGrouped = reduce(nodes, function (result, node) {\n    var shape = node.shape,\n        weight = node.weight,\n        distanceTo = node.distanceTo;\n    var fav = result.fav,\n        currentDistance,\n        currentDistanceCount,\n        currentDistanceEntry;\n    currentDistance = distanceTo(shape); // ignore too far away peers\n    // or non-left to right modeled nodes\n\n    if (currentDistance < 0 || currentDistance > MAX_HORIZONTAL_DISTANCE) {\n      return result;\n    }\n\n    currentDistanceEntry = result[String(currentDistance)] = result[String(currentDistance)] || {\n      value: currentDistance,\n      count: 0\n    }; // inc diff count\n\n    currentDistanceCount = currentDistanceEntry.count += 1 * weight;\n\n    if (!fav || fav.count < currentDistanceCount) {\n      result.fav = currentDistanceEntry;\n    }\n\n    return result;\n  }, {});\n\n  if (distancesGrouped.fav) {\n    return distancesGrouped.fav.value;\n  } else {\n    return DEFAULT_HORIZONTAL_DISTANCE;\n  }\n}\n/**\n * Always try to place text annotations top right of source.\n */\n\nexport function getTextAnnotationPosition(source, element) {\n  var sourceTrbl = asTRBL(source);\n  var position = {\n    x: sourceTrbl.right + element.width / 2,\n    y: sourceTrbl.top - 50 - element.height / 2\n  };\n  var escapeDirection = {\n    y: {\n      margin: -30,\n      rowSize: 20\n    }\n  };\n  return deconflictPosition(source, element, position, escapeDirection);\n}\n/**\n * Always put element bottom right of source.\n */\n\nexport function getDataElementPosition(source, element) {\n  var sourceTrbl = asTRBL(source);\n  var position = {\n    x: sourceTrbl.right - 10 + element.width / 2,\n    y: sourceTrbl.bottom + 40 + element.width / 2\n  };\n  var escapeDirection = {\n    x: {\n      margin: 30,\n      rowSize: 30\n    }\n  };\n  return deconflictPosition(source, element, position, escapeDirection);\n}\n/**\n * Always put element right of source per default.\n */\n\nexport function getDefaultPosition(source, element) {\n  var sourceTrbl = asTRBL(source);\n  var sourceMid = getMid(source); // simply put element right next to source\n\n  return {\n    x: sourceTrbl.right + DEFAULT_HORIZONTAL_DISTANCE + element.width / 2,\n    y: sourceMid.y\n  };\n}\n/**\n * Returns all connected elements around the given source.\n *\n * This includes:\n *\n *   - connected elements\n *   - host connected elements\n *   - attachers connected elements\n *\n * @param  {djs.model.Shape} source\n * @param  {djs.model.Shape} element\n *\n * @return {Array<djs.model.Shape>}\n */\n\nfunction getAutoPlaceClosure(source, element) {\n  var allConnected = getConnected(source);\n\n  if (source.host) {\n    allConnected = allConnected.concat(getConnected(source.host));\n  }\n\n  if (source.attachers) {\n    allConnected = allConnected.concat(source.attachers.reduce(function (shapes, attacher) {\n      return shapes.concat(getConnected(attacher));\n    }, []));\n  }\n\n  return allConnected;\n}\n/**\n * Return target at given position, if defined.\n *\n * This takes connected elements from host and attachers\n * into account, too.\n */\n\n\nexport function getConnectedAtPosition(source, position, element) {\n  var bounds = {\n    x: position.x - element.width / 2,\n    y: position.y - element.height / 2,\n    width: element.width,\n    height: element.height\n  };\n  var closure = getAutoPlaceClosure(source, element);\n  return find(closure, function (target) {\n    if (target === element) {\n      return false;\n    }\n\n    var orientation = getOrientation(target, bounds, PLACEMENT_DETECTION_PAD);\n    return orientation === 'intersect';\n  });\n}\n/**\n * Returns a new, position for the given element\n * based on the given element that is not occupied\n * by some element connected to source.\n *\n * Take into account the escapeDirection (where to move\n * on positioning clashes) in the computation.\n *\n * @param {djs.model.Shape} source\n * @param {djs.model.Shape} element\n * @param {Point} position\n * @param {Object} escapeDelta\n *\n * @return {Point}\n */\n\nexport function deconflictPosition(source, element, position, escapeDelta) {\n  function nextPosition(existingElement) {\n    var newPosition = {\n      x: position.x,\n      y: position.y\n    };\n    ['x', 'y'].forEach(function (axis) {\n      var axisDelta = escapeDelta[axis];\n\n      if (!axisDelta) {\n        return;\n      }\n\n      var dimension = axis === 'x' ? 'width' : 'height';\n      var margin = axisDelta.margin,\n          rowSize = axisDelta.rowSize;\n\n      if (margin < 0) {\n        newPosition[axis] = Math.min(existingElement[axis] + margin - element[dimension] / 2, position[axis] - rowSize + margin);\n      } else {\n        newPosition[axis] = Math.max(existingTarget[axis] + existingTarget[dimension] + margin + element[dimension] / 2, position[axis] + rowSize + margin);\n      }\n    });\n    return newPosition;\n  }\n\n  var existingTarget; // deconflict position until free slot is found\n\n  while (existingTarget = getConnectedAtPosition(source, position, element)) {\n    position = nextPosition(existingTarget);\n  }\n\n  return position;\n} // helpers //////////////////////\n\nfunction noneFilter() {\n  return true;\n}\n\nfunction getConnected(element, connectionFilter) {\n  return [].concat(getTargets(element, connectionFilter), getSources(element, connectionFilter));\n}\n\nfunction getSources(shape, connectionFilter) {\n  if (!connectionFilter) {\n    connectionFilter = noneFilter;\n  }\n\n  return shape.incoming.filter(connectionFilter).map(function (c) {\n    return c.source;\n  });\n}\n\nfunction getTargets(shape, connectionFilter) {\n  if (!connectionFilter) {\n    connectionFilter = noneFilter;\n  }\n\n  return shape.outgoing.filter(connectionFilter).map(function (c) {\n    return c.target;\n  });\n}","map":{"version":3,"sources":["/Users/believecreative/Kumar/bpmn/node_modules/bpmn-js/lib/features/auto-place/AutoPlaceUtil.js"],"names":["is","isAny","getMid","asTRBL","getOrientation","find","reduce","DEFAULT_HORIZONTAL_DISTANCE","MAX_HORIZONTAL_DISTANCE","PLACEMENT_DETECTION_PAD","getNewShapePosition","source","element","getTextAnnotationPosition","getDataElementPosition","getFlowNodePosition","getDefaultPosition","sourceTrbl","sourceMid","horizontalDistance","getFlowNodeDistance","orientation","rowSize","margin","host","indexOf","getVerticalDistance","orient","position","x","right","width","y","escapeDirection","deconflictPosition","isReference","c","toTargetNode","weight","shape","distanceTo","shapeTrbl","left","toSourceNode","nodes","concat","getTargets","map","getSources","node","id","distancesGrouped","result","fav","currentDistance","currentDistanceCount","currentDistanceEntry","String","value","count","top","height","bottom","getAutoPlaceClosure","allConnected","getConnected","attachers","shapes","attacher","getConnectedAtPosition","bounds","closure","target","escapeDelta","nextPosition","existingElement","newPosition","forEach","axis","axisDelta","dimension","Math","min","max","existingTarget","noneFilter","connectionFilter","incoming","filter","outgoing"],"mappings":"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","sourcesContent":["import { is } from '../../util/ModelUtil';\nimport { isAny } from '../modeling/util/ModelingUtil';\n\nimport {\n  getMid,\n  asTRBL,\n  getOrientation\n} from 'diagram-js/lib/layout/LayoutUtil';\n\nimport {\n  find,\n  reduce\n} from 'min-dash';\n\nvar DEFAULT_HORIZONTAL_DISTANCE = 50;\n\nvar MAX_HORIZONTAL_DISTANCE = 250;\n\n// padding to detect element placement\nvar PLACEMENT_DETECTION_PAD = 10;\n\n/**\n * Find the new position for the target element to\n * connect to source.\n *\n * @param  {djs.model.Shape} source\n * @param  {djs.model.Shape} element\n *\n * @return {Point}\n */\nexport function getNewShapePosition(source, element) {\n\n  if (is(element, 'bpmn:TextAnnotation')) {\n    return getTextAnnotationPosition(source, element);\n  }\n\n  if (isAny(element, [ 'bpmn:DataObjectReference', 'bpmn:DataStoreReference' ])) {\n    return getDataElementPosition(source, element);\n  }\n\n  if (is(element, 'bpmn:FlowNode')) {\n    return getFlowNodePosition(source, element);\n  }\n\n  return getDefaultPosition(source, element);\n}\n\n/**\n * Always try to place element right of source;\n * compute actual distance from previous nodes in flow.\n */\nexport function getFlowNodePosition(source, element) {\n\n  var sourceTrbl = asTRBL(source);\n  var sourceMid = getMid(source);\n\n  var horizontalDistance = getFlowNodeDistance(source, element);\n\n  var orientation = 'left',\n      rowSize = 80,\n      margin = 30;\n\n  if (is(source, 'bpmn:BoundaryEvent')) {\n    orientation = getOrientation(source, source.host, -25);\n\n    if (orientation.indexOf('top') !== -1) {\n      margin *= -1;\n    }\n  }\n\n  function getVerticalDistance(orient) {\n    if (orient.indexOf('top') != -1) {\n      return -1 * rowSize;\n    } else if (orient.indexOf('bottom') != -1) {\n      return rowSize;\n    } else {\n      return 0;\n    }\n  }\n\n  var position = {\n    x: sourceTrbl.right + horizontalDistance + element.width / 2,\n    y: sourceMid.y + getVerticalDistance(orientation)\n  };\n\n  var escapeDirection = {\n    y: {\n      margin: margin,\n      rowSize: rowSize\n    }\n  };\n\n  return deconflictPosition(source, element, position, escapeDirection);\n}\n\n\n/**\n * Compute best distance between source and target,\n * based on existing connections to and from source.\n *\n * @param {djs.model.Shape} source\n * @param {djs.model.Shape} element\n *\n * @return {Number} distance\n */\nexport function getFlowNodeDistance(source, element) {\n\n  var sourceTrbl = asTRBL(source);\n\n  // is connection a reference to consider?\n  function isReference(c) {\n    return is(c, 'bpmn:SequenceFlow');\n  }\n\n  function toTargetNode(weight) {\n\n    return function(shape) {\n      return {\n        shape: shape,\n        weight: weight,\n        distanceTo: function(shape) {\n          var shapeTrbl = asTRBL(shape);\n\n          return shapeTrbl.left - sourceTrbl.right;\n        }\n      };\n    };\n  }\n\n  function toSourceNode(weight) {\n    return function(shape) {\n      return {\n        shape: shape,\n        weight: weight,\n        distanceTo: function(shape) {\n          var shapeTrbl = asTRBL(shape);\n\n          return sourceTrbl.left - shapeTrbl.right;\n        }\n      };\n    };\n  }\n\n  // we create a list of nodes to take into consideration\n  // for calculating the optimal flow node distance\n  //\n  //   * weight existing target nodes higher than source nodes\n  //   * only take into account individual nodes once\n  //\n  var nodes = reduce([].concat(\n    getTargets(source, isReference).map(toTargetNode(5)),\n    getSources(source, isReference).map(toSourceNode(1))\n  ), function(nodes, node) {\n\n    // filter out shapes connected twice via source or target\n    nodes[node.shape.id + '__weight_' + node.weight] = node;\n\n    return nodes;\n  }, {});\n\n  // compute distances between source and incoming nodes;\n  // group at the same time by distance and expose the\n  // favourite distance as { fav: { count, value } }.\n  var distancesGrouped = reduce(nodes, function(result, node) {\n\n    var shape = node.shape,\n        weight = node.weight,\n        distanceTo = node.distanceTo;\n\n    var fav = result.fav,\n        currentDistance,\n        currentDistanceCount,\n        currentDistanceEntry;\n\n    currentDistance = distanceTo(shape);\n\n    // ignore too far away peers\n    // or non-left to right modeled nodes\n    if (currentDistance < 0 || currentDistance > MAX_HORIZONTAL_DISTANCE) {\n      return result;\n    }\n\n    currentDistanceEntry = result[String(currentDistance)] =\n      result[String(currentDistance)] || {\n        value: currentDistance,\n        count: 0\n      };\n\n    // inc diff count\n    currentDistanceCount = currentDistanceEntry.count += 1 * weight;\n\n    if (!fav || fav.count < currentDistanceCount) {\n      result.fav = currentDistanceEntry;\n    }\n\n    return result;\n  }, { });\n\n\n  if (distancesGrouped.fav) {\n    return distancesGrouped.fav.value;\n  } else {\n    return DEFAULT_HORIZONTAL_DISTANCE;\n  }\n}\n\n\n/**\n * Always try to place text annotations top right of source.\n */\nexport function getTextAnnotationPosition(source, element) {\n\n  var sourceTrbl = asTRBL(source);\n\n  var position = {\n    x: sourceTrbl.right + element.width / 2,\n    y: sourceTrbl.top - 50 - element.height / 2\n  };\n\n  var escapeDirection = {\n    y: {\n      margin: -30,\n      rowSize: 20\n    }\n  };\n\n  return deconflictPosition(source, element, position, escapeDirection);\n}\n\n\n/**\n * Always put element bottom right of source.\n */\nexport function getDataElementPosition(source, element) {\n\n  var sourceTrbl = asTRBL(source);\n\n  var position = {\n    x: sourceTrbl.right - 10 + element.width / 2,\n    y: sourceTrbl.bottom + 40 + element.width / 2\n  };\n\n  var escapeDirection = {\n    x: {\n      margin: 30,\n      rowSize: 30\n    }\n  };\n\n  return deconflictPosition(source, element, position, escapeDirection);\n}\n\n\n/**\n * Always put element right of source per default.\n */\nexport function getDefaultPosition(source, element) {\n\n  var sourceTrbl = asTRBL(source);\n\n  var sourceMid = getMid(source);\n\n  // simply put element right next to source\n  return {\n    x: sourceTrbl.right + DEFAULT_HORIZONTAL_DISTANCE + element.width / 2,\n    y: sourceMid.y\n  };\n}\n\n\n/**\n * Returns all connected elements around the given source.\n *\n * This includes:\n *\n *   - connected elements\n *   - host connected elements\n *   - attachers connected elements\n *\n * @param  {djs.model.Shape} source\n * @param  {djs.model.Shape} element\n *\n * @return {Array<djs.model.Shape>}\n */\nfunction getAutoPlaceClosure(source, element) {\n\n  var allConnected = getConnected(source);\n\n  if (source.host) {\n    allConnected = allConnected.concat(getConnected(source.host));\n  }\n\n  if (source.attachers) {\n    allConnected = allConnected.concat(source.attachers.reduce(function(shapes, attacher) {\n      return shapes.concat(getConnected(attacher));\n    }, []));\n  }\n\n  return allConnected;\n}\n\n/**\n * Return target at given position, if defined.\n *\n * This takes connected elements from host and attachers\n * into account, too.\n */\nexport function getConnectedAtPosition(source, position, element) {\n\n  var bounds = {\n    x: position.x - (element.width / 2),\n    y: position.y - (element.height / 2),\n    width: element.width,\n    height: element.height\n  };\n\n  var closure = getAutoPlaceClosure(source, element);\n\n  return find(closure, function(target) {\n\n    if (target === element) {\n      return false;\n    }\n\n    var orientation = getOrientation(target, bounds, PLACEMENT_DETECTION_PAD);\n\n    return orientation === 'intersect';\n  });\n}\n\n\n/**\n * Returns a new, position for the given element\n * based on the given element that is not occupied\n * by some element connected to source.\n *\n * Take into account the escapeDirection (where to move\n * on positioning clashes) in the computation.\n *\n * @param {djs.model.Shape} source\n * @param {djs.model.Shape} element\n * @param {Point} position\n * @param {Object} escapeDelta\n *\n * @return {Point}\n */\nexport function deconflictPosition(source, element, position, escapeDelta) {\n\n  function nextPosition(existingElement) {\n\n    var newPosition = {\n      x: position.x,\n      y: position.y\n    };\n\n    [ 'x', 'y' ].forEach(function(axis) {\n\n      var axisDelta = escapeDelta[axis];\n\n      if (!axisDelta) {\n        return;\n      }\n\n      var dimension = axis === 'x' ? 'width' : 'height';\n\n      var margin = axisDelta.margin,\n          rowSize = axisDelta.rowSize;\n\n      if (margin < 0) {\n        newPosition[axis] = Math.min(\n          existingElement[axis] + margin - element[dimension] / 2,\n          position[axis] - rowSize + margin\n        );\n      } else {\n        newPosition[axis] = Math.max(\n          existingTarget[axis] + existingTarget[dimension] + margin + element[dimension] / 2,\n          position[axis] + rowSize + margin\n        );\n      }\n    });\n\n    return newPosition;\n  }\n\n  var existingTarget;\n\n  // deconflict position until free slot is found\n  while ((existingTarget = getConnectedAtPosition(source, position, element))) {\n    position = nextPosition(existingTarget);\n  }\n\n  return position;\n}\n\n\n\n// helpers //////////////////////\n\nfunction noneFilter() {\n  return true;\n}\n\nfunction getConnected(element, connectionFilter) {\n  return [].concat(\n    getTargets(element, connectionFilter),\n    getSources(element, connectionFilter)\n  );\n}\n\nfunction getSources(shape, connectionFilter) {\n\n  if (!connectionFilter) {\n    connectionFilter = noneFilter;\n  }\n\n  return shape.incoming.filter(connectionFilter).map(function(c) {\n    return c.source;\n  });\n}\n\nfunction getTargets(shape, connectionFilter) {\n\n  if (!connectionFilter) {\n    connectionFilter = noneFilter;\n  }\n\n  return shape.outgoing.filter(connectionFilter).map(function(c) {\n    return c.target;\n  });\n}"]},"metadata":{},"sourceType":"module"}