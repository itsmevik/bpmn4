{"ast":null,"code":"import inherits from 'inherits';\nimport { assign, filter, find, isNumber } from 'min-dash';\nimport { getMid } from 'diagram-js/lib/layout/LayoutUtil';\nimport CommandInterceptor from 'diagram-js/lib/command/CommandInterceptor';\nimport { getApproxIntersection } from 'diagram-js/lib/util/LineIntersection';\nexport default function DropOnFlowBehavior(eventBus, bpmnRules, modeling) {\n  CommandInterceptor.call(this, eventBus);\n  /**\n   * Reconnect start / end of a connection after\n   * dropping an element on a flow.\n   */\n\n  function insertShape(shape, targetFlow, positionOrBounds) {\n    var waypoints = targetFlow.waypoints,\n        waypointsBefore,\n        waypointsAfter,\n        dockingPoint,\n        source,\n        target,\n        incomingConnection,\n        outgoingConnection,\n        oldOutgoing = shape.outgoing.slice(),\n        oldIncoming = shape.incoming.slice();\n    var mid;\n\n    if (isNumber(positionOrBounds.width)) {\n      mid = getMid(positionOrBounds);\n    } else {\n      mid = positionOrBounds;\n    }\n\n    var intersection = getApproxIntersection(waypoints, mid);\n\n    if (intersection) {\n      waypointsBefore = waypoints.slice(0, intersection.index);\n      waypointsAfter = waypoints.slice(intersection.index + (intersection.bendpoint ? 1 : 0)); // due to inaccuracy intersection might have been found\n\n      if (!waypointsBefore.length || !waypointsAfter.length) {\n        return;\n      }\n\n      dockingPoint = intersection.bendpoint ? waypoints[intersection.index] : mid; // if last waypointBefore is inside shape's bounds, ignore docking point\n\n      if (!isPointInsideBBox(shape, waypointsBefore[waypointsBefore.length - 1])) {\n        waypointsBefore.push(copy(dockingPoint));\n      } // if first waypointAfter is inside shape's bounds, ignore docking point\n\n\n      if (!isPointInsideBBox(shape, waypointsAfter[0])) {\n        waypointsAfter.unshift(copy(dockingPoint));\n      }\n    }\n\n    source = targetFlow.source;\n    target = targetFlow.target;\n\n    if (bpmnRules.canConnect(source, shape, targetFlow)) {\n      // reconnect source -> inserted shape\n      modeling.reconnectEnd(targetFlow, shape, waypointsBefore || mid);\n      incomingConnection = targetFlow;\n    }\n\n    if (bpmnRules.canConnect(shape, target, targetFlow)) {\n      if (!incomingConnection) {\n        // reconnect inserted shape -> end\n        modeling.reconnectStart(targetFlow, shape, waypointsAfter || mid);\n        outgoingConnection = targetFlow;\n      } else {\n        outgoingConnection = modeling.connect(shape, target, {\n          type: targetFlow.type,\n          waypoints: waypointsAfter\n        });\n      }\n    }\n\n    var duplicateConnections = [].concat(incomingConnection && filter(oldIncoming, function (connection) {\n      return connection.source === incomingConnection.source;\n    }) || [], outgoingConnection && filter(oldOutgoing, function (connection) {\n      return connection.target === outgoingConnection.target;\n    }) || []);\n\n    if (duplicateConnections.length) {\n      modeling.removeElements(duplicateConnections);\n    }\n  }\n\n  this.preExecute('elements.move', function (context) {\n    var newParent = context.newParent,\n        shapes = context.shapes,\n        delta = context.delta,\n        shape = shapes[0];\n\n    if (!shape || !newParent) {\n      return;\n    } // if the new parent is a connection,\n    // change it to the new parent's parent\n\n\n    if (newParent && newParent.waypoints) {\n      context.newParent = newParent = newParent.parent;\n    }\n\n    var shapeMid = getMid(shape);\n    var newShapeMid = {\n      x: shapeMid.x + delta.x,\n      y: shapeMid.y + delta.y\n    }; // find a connection which intersects with the\n    // element's mid point\n\n    var connection = find(newParent.children, function (element) {\n      var canInsert = bpmnRules.canInsert(shapes, element);\n      return canInsert && getApproxIntersection(element.waypoints, newShapeMid);\n    });\n\n    if (connection) {\n      context.targetFlow = connection;\n      context.position = newShapeMid;\n    }\n  }, true);\n  this.postExecuted('elements.move', function (context) {\n    var shapes = context.shapes,\n        targetFlow = context.targetFlow,\n        position = context.position;\n\n    if (targetFlow) {\n      insertShape(shapes[0], targetFlow, position);\n    }\n  }, true);\n  this.preExecute('shape.create', function (context) {\n    var parent = context.parent,\n        shape = context.shape;\n\n    if (bpmnRules.canInsert(shape, parent)) {\n      context.targetFlow = parent;\n      context.parent = parent.parent;\n    }\n  }, true);\n  this.postExecuted('shape.create', function (context) {\n    var shape = context.shape,\n        targetFlow = context.targetFlow,\n        positionOrBounds = context.position;\n\n    if (targetFlow) {\n      insertShape(shape, targetFlow, positionOrBounds);\n    }\n  }, true);\n}\ninherits(DropOnFlowBehavior, CommandInterceptor);\nDropOnFlowBehavior.$inject = ['eventBus', 'bpmnRules', 'modeling']; // helpers /////////////////////\n\nfunction isPointInsideBBox(bbox, point) {\n  var x = point.x,\n      y = point.y;\n  return x >= bbox.x && x <= bbox.x + bbox.width && y >= bbox.y && y <= bbox.y + bbox.height;\n}\n\nfunction copy(obj) {\n  return assign({}, obj);\n}","map":{"version":3,"sources":["/Users/believecreative/Kumar/bpmn/node_modules/bpmn-js/lib/features/modeling/behavior/DropOnFlowBehavior.js"],"names":["inherits","assign","filter","find","isNumber","getMid","CommandInterceptor","getApproxIntersection","DropOnFlowBehavior","eventBus","bpmnRules","modeling","call","insertShape","shape","targetFlow","positionOrBounds","waypoints","waypointsBefore","waypointsAfter","dockingPoint","source","target","incomingConnection","outgoingConnection","oldOutgoing","outgoing","slice","oldIncoming","incoming","mid","width","intersection","index","bendpoint","length","isPointInsideBBox","push","copy","unshift","canConnect","reconnectEnd","reconnectStart","connect","type","duplicateConnections","concat","connection","removeElements","preExecute","context","newParent","shapes","delta","parent","shapeMid","newShapeMid","x","y","children","element","canInsert","position","postExecuted","$inject","bbox","point","height","obj"],"mappings":"AAAA,OAAOA,QAAP,MAAqB,UAArB;AAEA,SACEC,MADF,EAEEC,MAFF,EAGEC,IAHF,EAIEC,QAJF,QAKO,UALP;AAOA,SAASC,MAAT,QAAuB,kCAAvB;AAEA,OAAOC,kBAAP,MAA+B,2CAA/B;AAEA,SACEC,qBADF,QAEO,sCAFP;AAKA,eAAe,SAASC,kBAAT,CAA4BC,QAA5B,EAAsCC,SAAtC,EAAiDC,QAAjD,EAA2D;AAExEL,EAAAA,kBAAkB,CAACM,IAAnB,CAAwB,IAAxB,EAA8BH,QAA9B;AAEA;;;;;AAKA,WAASI,WAAT,CAAqBC,KAArB,EAA4BC,UAA5B,EAAwCC,gBAAxC,EAA0D;AACxD,QAAIC,SAAS,GAAGF,UAAU,CAACE,SAA3B;AAAA,QACIC,eADJ;AAAA,QAEIC,cAFJ;AAAA,QAGIC,YAHJ;AAAA,QAIIC,MAJJ;AAAA,QAKIC,MALJ;AAAA,QAMIC,kBANJ;AAAA,QAOIC,kBAPJ;AAAA,QAQIC,WAAW,GAAGX,KAAK,CAACY,QAAN,CAAeC,KAAf,EARlB;AAAA,QASIC,WAAW,GAAGd,KAAK,CAACe,QAAN,CAAeF,KAAf,EATlB;AAWA,QAAIG,GAAJ;;AAEA,QAAI1B,QAAQ,CAACY,gBAAgB,CAACe,KAAlB,CAAZ,EAAsC;AACpCD,MAAAA,GAAG,GAAGzB,MAAM,CAACW,gBAAD,CAAZ;AACD,KAFD,MAEO;AACLc,MAAAA,GAAG,GAAGd,gBAAN;AACD;;AAED,QAAIgB,YAAY,GAAGzB,qBAAqB,CAACU,SAAD,EAAYa,GAAZ,CAAxC;;AAEA,QAAIE,YAAJ,EAAkB;AAChBd,MAAAA,eAAe,GAAGD,SAAS,CAACU,KAAV,CAAgB,CAAhB,EAAmBK,YAAY,CAACC,KAAhC,CAAlB;AACAd,MAAAA,cAAc,GAAGF,SAAS,CAACU,KAAV,CAAgBK,YAAY,CAACC,KAAb,IAAsBD,YAAY,CAACE,SAAb,GAAyB,CAAzB,GAA6B,CAAnD,CAAhB,CAAjB,CAFgB,CAIhB;;AACA,UAAI,CAAChB,eAAe,CAACiB,MAAjB,IAA2B,CAAChB,cAAc,CAACgB,MAA/C,EAAuD;AACrD;AACD;;AAEDf,MAAAA,YAAY,GAAGY,YAAY,CAACE,SAAb,GAAyBjB,SAAS,CAACe,YAAY,CAACC,KAAd,CAAlC,GAAyDH,GAAxE,CATgB,CAWhB;;AACA,UAAI,CAACM,iBAAiB,CAACtB,KAAD,EAAQI,eAAe,CAACA,eAAe,CAACiB,MAAhB,GAAuB,CAAxB,CAAvB,CAAtB,EAA0E;AACxEjB,QAAAA,eAAe,CAACmB,IAAhB,CAAqBC,IAAI,CAAClB,YAAD,CAAzB;AACD,OAde,CAgBhB;;;AACA,UAAI,CAACgB,iBAAiB,CAACtB,KAAD,EAAQK,cAAc,CAAC,CAAD,CAAtB,CAAtB,EAAkD;AAChDA,QAAAA,cAAc,CAACoB,OAAf,CAAuBD,IAAI,CAAClB,YAAD,CAA3B;AACD;AACF;;AAEDC,IAAAA,MAAM,GAAGN,UAAU,CAACM,MAApB;AACAC,IAAAA,MAAM,GAAGP,UAAU,CAACO,MAApB;;AAEA,QAAIZ,SAAS,CAAC8B,UAAV,CAAqBnB,MAArB,EAA6BP,KAA7B,EAAoCC,UAApC,CAAJ,EAAqD;AAEnD;AACAJ,MAAAA,QAAQ,CAAC8B,YAAT,CAAsB1B,UAAtB,EAAkCD,KAAlC,EAAyCI,eAAe,IAAIY,GAA5D;AAEAP,MAAAA,kBAAkB,GAAGR,UAArB;AACD;;AAED,QAAIL,SAAS,CAAC8B,UAAV,CAAqB1B,KAArB,EAA4BQ,MAA5B,EAAoCP,UAApC,CAAJ,EAAqD;AAEnD,UAAI,CAACQ,kBAAL,EAAyB;AAEvB;AACAZ,QAAAA,QAAQ,CAAC+B,cAAT,CAAwB3B,UAAxB,EAAoCD,KAApC,EAA2CK,cAAc,IAAIW,GAA7D;AAEAN,QAAAA,kBAAkB,GAAGT,UAArB;AACD,OAND,MAMO;AACLS,QAAAA,kBAAkB,GAAGb,QAAQ,CAACgC,OAAT,CACnB7B,KADmB,EACZQ,MADY,EACJ;AAAEsB,UAAAA,IAAI,EAAE7B,UAAU,CAAC6B,IAAnB;AAAyB3B,UAAAA,SAAS,EAAEE;AAApC,SADI,CAArB;AAGD;AACF;;AAED,QAAI0B,oBAAoB,GAAG,GAAGC,MAAH,CAEzBvB,kBAAkB,IAAIrB,MAAM,CAAC0B,WAAD,EAAc,UAASmB,UAAT,EAAqB;AAC7D,aAAOA,UAAU,CAAC1B,MAAX,KAAsBE,kBAAkB,CAACF,MAAhD;AACD,KAF2B,CAA5B,IAEM,EAJmB,EAMzBG,kBAAkB,IAAItB,MAAM,CAACuB,WAAD,EAAc,UAASsB,UAAT,EAAqB;AAC7D,aAAOA,UAAU,CAACzB,MAAX,KAAsBE,kBAAkB,CAACF,MAAhD;AACD,KAF2B,CAA5B,IAEM,EARmB,CAA3B;;AAWA,QAAIuB,oBAAoB,CAACV,MAAzB,EAAiC;AAC/BxB,MAAAA,QAAQ,CAACqC,cAAT,CAAwBH,oBAAxB;AACD;AACF;;AAED,OAAKI,UAAL,CAAgB,eAAhB,EAAiC,UAASC,OAAT,EAAkB;AAEjD,QAAIC,SAAS,GAAGD,OAAO,CAACC,SAAxB;AAAA,QACIC,MAAM,GAAGF,OAAO,CAACE,MADrB;AAAA,QAEIC,KAAK,GAAGH,OAAO,CAACG,KAFpB;AAAA,QAGIvC,KAAK,GAAGsC,MAAM,CAAC,CAAD,CAHlB;;AAKA,QAAI,CAACtC,KAAD,IAAU,CAACqC,SAAf,EAA0B;AACxB;AACD,KATgD,CAWjD;AACA;;;AACA,QAAIA,SAAS,IAAIA,SAAS,CAAClC,SAA3B,EAAsC;AACpCiC,MAAAA,OAAO,CAACC,SAAR,GAAoBA,SAAS,GAAGA,SAAS,CAACG,MAA1C;AACD;;AAED,QAAIC,QAAQ,GAAGlD,MAAM,CAACS,KAAD,CAArB;AACA,QAAI0C,WAAW,GAAG;AAChBC,MAAAA,CAAC,EAAEF,QAAQ,CAACE,CAAT,GAAaJ,KAAK,CAACI,CADN;AAEhBC,MAAAA,CAAC,EAAEH,QAAQ,CAACG,CAAT,GAAaL,KAAK,CAACK;AAFN,KAAlB,CAlBiD,CAuBjD;AACA;;AACA,QAAIX,UAAU,GAAG5C,IAAI,CAACgD,SAAS,CAACQ,QAAX,EAAqB,UAASC,OAAT,EAAkB;AAC1D,UAAIC,SAAS,GAAGnD,SAAS,CAACmD,SAAV,CAAoBT,MAApB,EAA4BQ,OAA5B,CAAhB;AAEA,aAAOC,SAAS,IAAItD,qBAAqB,CAACqD,OAAO,CAAC3C,SAAT,EAAoBuC,WAApB,CAAzC;AACD,KAJoB,CAArB;;AAMA,QAAIT,UAAJ,EAAgB;AACdG,MAAAA,OAAO,CAACnC,UAAR,GAAqBgC,UAArB;AACAG,MAAAA,OAAO,CAACY,QAAR,GAAmBN,WAAnB;AACD;AAEF,GApCD,EAoCG,IApCH;AAsCA,OAAKO,YAAL,CAAkB,eAAlB,EAAmC,UAASb,OAAT,EAAkB;AAEnD,QAAIE,MAAM,GAAGF,OAAO,CAACE,MAArB;AAAA,QACIrC,UAAU,GAAGmC,OAAO,CAACnC,UADzB;AAAA,QAEI+C,QAAQ,GAAGZ,OAAO,CAACY,QAFvB;;AAIA,QAAI/C,UAAJ,EAAgB;AACdF,MAAAA,WAAW,CAACuC,MAAM,CAAC,CAAD,CAAP,EAAYrC,UAAZ,EAAwB+C,QAAxB,CAAX;AACD;AAEF,GAVD,EAUG,IAVH;AAYA,OAAKb,UAAL,CAAgB,cAAhB,EAAgC,UAASC,OAAT,EAAkB;AAEhD,QAAII,MAAM,GAAGJ,OAAO,CAACI,MAArB;AAAA,QACIxC,KAAK,GAAGoC,OAAO,CAACpC,KADpB;;AAGA,QAAIJ,SAAS,CAACmD,SAAV,CAAoB/C,KAApB,EAA2BwC,MAA3B,CAAJ,EAAwC;AACtCJ,MAAAA,OAAO,CAACnC,UAAR,GAAqBuC,MAArB;AACAJ,MAAAA,OAAO,CAACI,MAAR,GAAiBA,MAAM,CAACA,MAAxB;AACD;AACF,GATD,EASG,IATH;AAWA,OAAKS,YAAL,CAAkB,cAAlB,EAAkC,UAASb,OAAT,EAAkB;AAElD,QAAIpC,KAAK,GAAGoC,OAAO,CAACpC,KAApB;AAAA,QACIC,UAAU,GAAGmC,OAAO,CAACnC,UADzB;AAAA,QAEIC,gBAAgB,GAAGkC,OAAO,CAACY,QAF/B;;AAIA,QAAI/C,UAAJ,EAAgB;AACdF,MAAAA,WAAW,CAACC,KAAD,EAAQC,UAAR,EAAoBC,gBAApB,CAAX;AACD;AACF,GATD,EASG,IATH;AAUD;AAEDhB,QAAQ,CAACQ,kBAAD,EAAqBF,kBAArB,CAAR;AAEAE,kBAAkB,CAACwD,OAAnB,GAA6B,CAC3B,UAD2B,EAE3B,WAF2B,EAG3B,UAH2B,CAA7B,C,CAOA;;AAEA,SAAS5B,iBAAT,CAA2B6B,IAA3B,EAAiCC,KAAjC,EAAwC;AACtC,MAAIT,CAAC,GAAGS,KAAK,CAACT,CAAd;AAAA,MACIC,CAAC,GAAGQ,KAAK,CAACR,CADd;AAGA,SAAOD,CAAC,IAAIQ,IAAI,CAACR,CAAV,IACLA,CAAC,IAAIQ,IAAI,CAACR,CAAL,GAASQ,IAAI,CAAClC,KADd,IAEL2B,CAAC,IAAIO,IAAI,CAACP,CAFL,IAGLA,CAAC,IAAIO,IAAI,CAACP,CAAL,GAASO,IAAI,CAACE,MAHrB;AAID;;AAED,SAAS7B,IAAT,CAAc8B,GAAd,EAAmB;AACjB,SAAOnE,MAAM,CAAC,EAAD,EAAKmE,GAAL,CAAb;AACD","sourcesContent":["import inherits from 'inherits';\n\nimport {\n  assign,\n  filter,\n  find,\n  isNumber\n} from 'min-dash';\n\nimport { getMid } from 'diagram-js/lib/layout/LayoutUtil';\n\nimport CommandInterceptor from 'diagram-js/lib/command/CommandInterceptor';\n\nimport {\n  getApproxIntersection\n} from 'diagram-js/lib/util/LineIntersection';\n\n\nexport default function DropOnFlowBehavior(eventBus, bpmnRules, modeling) {\n\n  CommandInterceptor.call(this, eventBus);\n\n  /**\n   * Reconnect start / end of a connection after\n   * dropping an element on a flow.\n   */\n\n  function insertShape(shape, targetFlow, positionOrBounds) {\n    var waypoints = targetFlow.waypoints,\n        waypointsBefore,\n        waypointsAfter,\n        dockingPoint,\n        source,\n        target,\n        incomingConnection,\n        outgoingConnection,\n        oldOutgoing = shape.outgoing.slice(),\n        oldIncoming = shape.incoming.slice();\n\n    var mid;\n\n    if (isNumber(positionOrBounds.width)) {\n      mid = getMid(positionOrBounds);\n    } else {\n      mid = positionOrBounds;\n    }\n\n    var intersection = getApproxIntersection(waypoints, mid);\n\n    if (intersection) {\n      waypointsBefore = waypoints.slice(0, intersection.index);\n      waypointsAfter = waypoints.slice(intersection.index + (intersection.bendpoint ? 1 : 0));\n\n      // due to inaccuracy intersection might have been found\n      if (!waypointsBefore.length || !waypointsAfter.length) {\n        return;\n      }\n\n      dockingPoint = intersection.bendpoint ? waypoints[intersection.index] : mid;\n\n      // if last waypointBefore is inside shape's bounds, ignore docking point\n      if (!isPointInsideBBox(shape, waypointsBefore[waypointsBefore.length-1])) {\n        waypointsBefore.push(copy(dockingPoint));\n      }\n\n      // if first waypointAfter is inside shape's bounds, ignore docking point\n      if (!isPointInsideBBox(shape, waypointsAfter[0])) {\n        waypointsAfter.unshift(copy(dockingPoint));\n      }\n    }\n\n    source = targetFlow.source;\n    target = targetFlow.target;\n\n    if (bpmnRules.canConnect(source, shape, targetFlow)) {\n\n      // reconnect source -> inserted shape\n      modeling.reconnectEnd(targetFlow, shape, waypointsBefore || mid);\n\n      incomingConnection = targetFlow;\n    }\n\n    if (bpmnRules.canConnect(shape, target, targetFlow)) {\n\n      if (!incomingConnection) {\n\n        // reconnect inserted shape -> end\n        modeling.reconnectStart(targetFlow, shape, waypointsAfter || mid);\n\n        outgoingConnection = targetFlow;\n      } else {\n        outgoingConnection = modeling.connect(\n          shape, target, { type: targetFlow.type, waypoints: waypointsAfter }\n        );\n      }\n    }\n\n    var duplicateConnections = [].concat(\n\n      incomingConnection && filter(oldIncoming, function(connection) {\n        return connection.source === incomingConnection.source;\n      }) || [],\n\n      outgoingConnection && filter(oldOutgoing, function(connection) {\n        return connection.target === outgoingConnection.target;\n      }) || []\n    );\n\n    if (duplicateConnections.length) {\n      modeling.removeElements(duplicateConnections);\n    }\n  }\n\n  this.preExecute('elements.move', function(context) {\n\n    var newParent = context.newParent,\n        shapes = context.shapes,\n        delta = context.delta,\n        shape = shapes[0];\n\n    if (!shape || !newParent) {\n      return;\n    }\n\n    // if the new parent is a connection,\n    // change it to the new parent's parent\n    if (newParent && newParent.waypoints) {\n      context.newParent = newParent = newParent.parent;\n    }\n\n    var shapeMid = getMid(shape);\n    var newShapeMid = {\n      x: shapeMid.x + delta.x,\n      y: shapeMid.y + delta.y\n    };\n\n    // find a connection which intersects with the\n    // element's mid point\n    var connection = find(newParent.children, function(element) {\n      var canInsert = bpmnRules.canInsert(shapes, element);\n\n      return canInsert && getApproxIntersection(element.waypoints, newShapeMid);\n    });\n\n    if (connection) {\n      context.targetFlow = connection;\n      context.position = newShapeMid;\n    }\n\n  }, true);\n\n  this.postExecuted('elements.move', function(context) {\n\n    var shapes = context.shapes,\n        targetFlow = context.targetFlow,\n        position = context.position;\n\n    if (targetFlow) {\n      insertShape(shapes[0], targetFlow, position);\n    }\n\n  }, true);\n\n  this.preExecute('shape.create', function(context) {\n\n    var parent = context.parent,\n        shape = context.shape;\n\n    if (bpmnRules.canInsert(shape, parent)) {\n      context.targetFlow = parent;\n      context.parent = parent.parent;\n    }\n  }, true);\n\n  this.postExecuted('shape.create', function(context) {\n\n    var shape = context.shape,\n        targetFlow = context.targetFlow,\n        positionOrBounds = context.position;\n\n    if (targetFlow) {\n      insertShape(shape, targetFlow, positionOrBounds);\n    }\n  }, true);\n}\n\ninherits(DropOnFlowBehavior, CommandInterceptor);\n\nDropOnFlowBehavior.$inject = [\n  'eventBus',\n  'bpmnRules',\n  'modeling'\n];\n\n\n// helpers /////////////////////\n\nfunction isPointInsideBBox(bbox, point) {\n  var x = point.x,\n      y = point.y;\n\n  return x >= bbox.x &&\n    x <= bbox.x + bbox.width &&\n    y >= bbox.y &&\n    y <= bbox.y + bbox.height;\n}\n\nfunction copy(obj) {\n  return assign({}, obj);\n}\n\n"]},"metadata":{},"sourceType":"module"}